---
sidebar_position: 7
---
import TwoColumn from '@site/src/components/TwoColumn';
import CodeSnippet from '@site/src/components/CodeSnippet.tsx';
import * as snippets from '@site/snippets/code-snippets01.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# TP 5 : SPI (Interface P√©riph√©rique S√©rie)

## 1. Introduction

Dans ce TP, nous allons explorer le protocole de communication SPI, largement utilis√© dans les syst√®mes embarqu√©s pour les √©changes de donn√©es entre deux ou plusieurs p√©riph√©riques.  
L‚Äôobjectif final sera de construire un lecteur audio sur la carte de laboratoire, qui lira des fichiers *.wav* depuis une carte SD et les jouera √† l‚Äôaide du haut-parleur int√©gr√©.

---

## 2. Protocole SPI (Serial Peripheral Interface)

SPI est une norme de communication synchrone d√©velopp√©e par Motorola. Elle fonctionne en mode **full-duplex** (transfert de donn√©es simultan√© dans les deux directions).

La communication repose sur une architecture **Ma√Ætre-Esclave** (un p√©riph√©rique Ma√Ætre et un ou plusieurs Esclaves). Le **Ma√Ætre** initie toujours la communication.

SPI est aussi appel√© protocole √† *quatre fils*, car il utilise quatre lignes distinctes :

- **MOSI** ‚Äî Master Out Slave In (donn√©es envoy√©es du **Ma√Ætre** vers l‚Äô**Esclave**)
- **MISO** ‚Äî Master In Slave Out (donn√©es envoy√©es de l‚Äô**Esclave** vers le **Ma√Ætre**)
- **SCLK** ‚Äî Horloge s√©rie (signal d‚Äôhorloge g√©n√©r√© par le **Ma√Ætre**)
- **CS / SS** ‚Äî Chip Select / Slave Select (utilis√© par le **Ma√Ætre** pour s√©lectionner un **Esclave** ; actif √† l‚Äô√©tat BAS)

![Sch√©ma du bus SPI]( ./images/spi1.png?500 )

---

### 2.1 Connexion de plusieurs Esclaves

Plusieurs p√©riph√©riques **Esclaves** peuvent √™tre connect√©s √† un seul **Ma√Ætre**. Les lignes *MOSI*, *MISO* et *SCLK* sont partag√©es, tandis que chaque **Esclave** poss√®de sa propre ligne *CS / SS*.

Quand le **Ma√Ætre** souhaite communiquer avec un **Esclave** sp√©cifique, il place la ligne *CS / SS* correspondante √† l‚Äô√©tat **BAS** (actif). Toutes les autres lignes *SS* restent **HAUTES**, et les **Esclaves** concern√©s ignorent la communication.

![Connexion de plusieurs Esclaves]( ./images/spi2.png?500 )

---

## 3. Transmission de Donn√©es en SPI

Pour d√©marrer la communication :
1. Le **Ma√Ætre** d√©finit la fr√©quence d‚Äôhorloge (elle ne doit pas d√©passer la vitesse maximale support√©e par l‚Äô**Esclave**).
2. Il s√©lectionne l‚Äô**Esclave** en pla√ßant sa ligne *CS / SS* √† **BAS**.

Pendant chaque cycle d‚Äôhorloge SPI (mode full-duplex) :
- Le **Ma√Ætre** envoie un bit via *MOSI*, que l‚Äô**Esclave** lit.
- Simultan√©ment, l‚Äô**Esclave** envoie un bit via *MISO*, que le **Ma√Ætre** lit.

Cela s‚Äôeffectue g√©n√©ralement √† l‚Äôaide de **registres √† d√©calage** connect√©s en boucle dans le **Ma√Ætre** et l‚Äô**Esclave**.

![Registre √† d√©calage SPI]( ./images/spi4.png?500 )

En g√©n√©ral :
- Le bit de poids fort (MSB) est envoy√© en premier.
- Une fois un mot transmis, les deux p√©riph√©riques ont √©chang√© l‚Äôensemble du contenu de leurs registres √† d√©calage.

Une fois la transmission termin√©e :
- Le **Ma√Ætre** arr√™te le signal d‚Äôhorloge (*SCLK*).
- Il d√©s√©lectionne l‚Äô**Esclave** en pla√ßant la ligne *CS / SS* correspondante √† **HAUT**.

![Transaction SPI compl√®te]( ./images/spi5.png?500 )

**Remarque** : Tous les **Esclaves** non s√©lectionn√©s ignorent les lignes *SCLK* et *MOSI*, et ne pilotent pas la ligne *MISO*.  
Un seul **Esclave** peut √™tre s√©lectionn√© √† la fois par le **Ma√Ætre**.


## 4. SPI sur l‚ÄôATMega324

Le microcontr√¥leur ATMega324 fournit une interface SPI pouvant fonctionner en mode **Ma√Ætre** ou **Esclave**.

Comme d‚Äôhabitude, la configuration et l‚Äôutilisation de cette interface impliquent l‚Äôutilisation de registres de contr√¥le, de statut et de donn√©es.

La description compl√®te des registres li√©s au SPI se trouve dans la [fiche technique de l‚ÄôATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf), chapitre : **SPI ‚Äì Serial Peripheral Interface** (√† partir de la page 214).

Voici un aper√ßu des registres SPI les plus importants :

---

### Registre de Contr√¥le SPI (SPCR)

| Bit   | Nom     | Description |
|-------|----------|-------------|
| 6     | **SPE**   | Activation du SPI ‚Äî Mettre √† 1 pour activer l‚Äôinterface SPI |
| 5     | **DORD**  | Ordre des bits ‚Äî 1 : LSB en premier, 0 : MSB en premier |
| 4     | **MSTR**  | S√©lection Ma√Ætre/Esclave ‚Äî 1 : mode Ma√Ætre, 0 : mode Esclave |
| 3-0   | **CPOL, CPHA, SPR1, SPR0** | Polarit√©, phase et fr√©quence de l‚Äôhorloge SPI |

![Registre SPCR](./images/spcr.png?700)

---

### Registre de Statut SPI (SPSR)

| Bit   | Nom     | Description |
|-------|----------|-------------|
| 7     | **SPIF**  | Drapeau d‚Äôinterruption SPI ‚Äî Mis √† 1 quand un transfert est termin√© |

![Registre SPSR](./images/spsr.png?700)

---

### Registre de Donn√©es SPI (SPDR)

Le registre **SPDR** est utilis√© √† la fois pour transmettre et recevoir des donn√©es :
- √âcrire dans ce registre **d√©marre une nouvelle transmission** (en mode **Ma√Ætre**).
- Lire dans ce registre permet d‚Äôobtenir les donn√©es re√ßues via SPI.

![Registre SPDR](./images/spdr.png?700)

---

## 5. Carte SD au format FAT

La carte de laboratoire int√®gre un lecteur de carte SD qui communique avec le microcontr√¥leur ATMega324 via le protocole SPI ‚Äî c‚Äôest l‚Äôapplication principale du TP d‚Äôaujourd‚Äôhui.

Le sch√©ma ci-dessous montre comment le lecteur de carte SD est connect√© au microcontr√¥leur. Remarquez que certaines broches d√©j√† utilis√©es dans les TP pr√©c√©dents sont ici r√©utilis√©es pour les signaux SPI.

![Connexion SPI avec Carte SD](./images/spi_sd1_ss.png)

---

### Format de la carte SD : FAT32

Les cartes SD que nous utiliserons sont format√©es avec le syst√®me de fichiers **FAT32**. Pour simplifier les op√©rations sur les fichiers, nous utiliserons la biblioth√®que **Petit FAT Filesystem** ‚Äî choisie pour sa faible empreinte m√©moire (2‚Äì4 Ko) et sa consommation RAM minimale (seulement 46 octets + pile).

---

### API de la biblioth√®que Petit FAT Filesystem

Voici les principales fonctions fournies par la biblioth√®que :

```c
FRESULT pf_mount (FATFS*);                   // Monter ou d√©monter un volume
FRESULT pf_open (const char*);               // Ouvrir un fichier
FRESULT pf_read (void*, WORD, WORD*);        // Lire des donn√©es depuis un fichier
FRESULT pf_write (const void*, WORD, WORD*); // √âcrire des donn√©es dans un fichier
FRESULT pf_lseek (DWORD);                    // D√©placer le pointeur de fichier
FRESULT pf_opendir (DIR*, const char*);      // Ouvrir un r√©pertoire
FRESULT pf_readdir (DIR*, FILINFO*);         // Lire un r√©pertoire
```

Ces fonctions permettent un acc√®s bas niveau aux fichiers depuis un syst√®me embarqu√© ‚Äî exactement ce dont nous avons besoin pour impl√©menter un lecteur audio de base sur notre carte √† microcontr√¥leur.

## 6. Exercices

üì• **T√©l√©chargez l‚Äôarchive du code de d√©part :**  
[lab5_skel.zip](https://ocw.cs.pub.ro/courses/_media/pm/lab/lab5_skel.zip)

Dans ce TP, vous n‚Äôaurez pas beaucoup de code √† √©crire, mais il est important de bien comprendre comment votre code interagit avec le squelette fourni et le comportement des fonctions de biblioth√®que que vous utiliserez.

---

### T√¢che 1 : Contr√¥le SPI (2p)

Impl√©mentez les fonctions de communication SPI de base dans `spi.c` :
- `SPI_init()`
- `SPI_exchange()`

:::tip

- Configurez **PB4 (SS)** comme sortie et mettez-le √† **HAUT** pour d√©sactiver les interruptions SPI d√©clench√©es par la s√©lection esclave.
- Suivez les exemples de la **page 217** de la fiche technique.
- R√©f√©rez-vous au sch√©ma de c√¢blage de la section 5 pour identifier les broches **MOSI** et **SCLK**.
- Configurez le SPI en mode **Ma√Ætre** avec **SCLK = fosc/16** (fr√©quence plus lente pour compatibilit√© avec la carte SD).
- N‚Äôoubliez pas d‚Äôutiliser les registres avec suffixe `0` : `SPCR0`, `SPDR0`, etc.
- Utilisez `SPDR0` pour envoyer une donn√©e et recevoir la r√©ponse dans une seule fonction (full-duplex), rempla√ßant ainsi les fonctions `SPI_read()` et `SPI_write()`.

:::

---

### T√¢che 2 : Contr√¥le de la carte SD (2p)

Dans `sd.c`, impl√©mentez :
- `SD_init()`
- `SD_receive()`
- `SD_transmit()`

:::tip
- **PA2** (SS pour la carte SD) doit √™tre configur√©e en sortie. Laissez la gestion des niveaux HAUT/BAS au code squelette.
- Utilisez `SPI_exchange()` √† la fois pour l‚Äô√©mission et la r√©ception.
- Dans `SD_receive()`, envoyez **0xFF** comme octet factice pour initier une lecture (le Ma√Ætre initie toujours la communication).
- ‚úÖ **V√©rification** : Apr√®s avoir t√©l√©vers√© le code, l‚Äô√©cran LCD doit afficher `Mounted!` au lieu de `Mounting...`. Si ce n‚Äôest pas le cas, appuyez sur **RESET** et effectuez un d√©bogage si n√©cessaire.
:::

---

### T√¢che 3 : Affichage du premier fichier (2p)

Impl√©mentez `init_directory()` dans `lab5.c` pour afficher le premier fichier `.wav` du dossier `/music` :
- Utilisez `pf_opendir()` pour ouvrir le dossier.
- Utilisez `pf_readdir()` pour parcourir les entr√©es.
- Ignorez les fichiers dont le nom commence par un underscore `_`.
- Utilisez `LCD_clear_top_line()` et `LCD_printAt()` pour afficher le nom du fichier.

---

### POINT DE CONTR√îLE (1pt)

> Apr√®s quelques secondes, l‚Äô√©cran LCD doit afficher : **"Mounted!"**

Cela confirme que la carte SD a bien √©t√© initialis√©e et mont√©e.

---

### T√¢che 3 ‚Äì Lecture de la temp√©rature (2pts)

Configurez l‚ÄôADC et lisez la temp√©rature depuis un capteur analogique (par exemple LM35).

#### √âtapes d‚Äôimpl√©mentation :
- Cr√©ez et impl√©mentez `adc_init()` et `adc_read()`
- Configurez :
  - Tension de r√©f√©rence : **AVcc**
  - Prescaler ADC : **8**
- Convertissez la valeur ADC en tension, puis en ¬∞C (ex : `temp = voltage * 100`)
- Affichez la temp√©rature sur l‚Äô√©cran **LCD**
- Envoyez aussi la lecture via **USART** (s√©rie)

---

### T√¢che 4 ‚Äì Enregistrement des temp√©ratures sur carte SD (2pts)

Impl√©mentez `log_temperature()` dans `lab5.c` pour sauvegarder les temp√©ratures dans un fichier **CSV**.

#### Exigences :
- Utilisez `SD_log_data()` pour √©crire dans le fichier
- Affichez la temp√©rature actuelle sur le **LCD**
- Envoyez la temp√©rature via **USART**
- Lorsqu‚Äôon appuie sur le bouton **PD6**, ajoutez une nouvelle ligne de log

---

### T√¢che 5 ‚Äì Navigation dans les enregistrements (2pts)

Impl√©mentez `init_log_display()` et `next_log_entry()` pour lire le fichier `log.csv` **ligne par ligne**.

#### Fonctionnalit√©s :
- Affichez chaque ligne du CSV (entr√©e) sur le **LCD**
- En appuyant sur le bouton **PB2**, passez √† la **ligne suivante**
- Une fois la fin atteinte, recommencez √† partir du **d√©but**

---

### POINT DE CONTR√îLE (1pt)

> Vous devez pouvoir faire d√©filer tous les enregistrements de temp√©rature √† l‚Äôaide du bouton.

Une fois termin√©, votre enregistreur doit permettre :
- Lecture temps r√©el du capteur
- Enregistrement sur bouton-poussoir
- Navigation compl√®te dans les logs via l‚Äô√©cran LCD et un bouton


## üîó Liens utiles

- üìò [Fiche technique ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf)
- üíæ [Tutoriel sur carte SD au format FAT](https://codeandlife.com/2012/04/25/simple-fat-and-sd-tutorial-part-3/)
- üîÑ [Guide du protocole SPI](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all)

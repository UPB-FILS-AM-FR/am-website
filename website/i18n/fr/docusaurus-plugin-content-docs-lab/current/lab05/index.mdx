---
sidebar_position: 7
---
import TwoColumn from '@site/src/components/TwoColumn';
import CodeSnippet from '@site/src/components/CodeSnippet.tsx';
import * as snippets from '@site/snippets/code-snippets01.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# TP 5 : SPI (Interface PÃ©riphÃ©rique SÃ©rie)

## 1. Introduction

Dans ce TP, nous allons explorer le protocole de communication SPI, largement utilisÃ© dans les systÃ¨mes embarquÃ©s pour les Ã©changes de donnÃ©es entre deux ou plusieurs pÃ©riphÃ©riques.  
Lâ€™objectif final sera de construire un lecteur audio sur la carte de laboratoire, qui lira des fichiers *.wav* depuis une carte SD et les jouera Ã  lâ€™aide du haut-parleur intÃ©grÃ©.

---

## 2. Protocole SPI (Serial Peripheral Interface)

SPI est une norme de communication synchrone dÃ©veloppÃ©e par Motorola. Elle fonctionne en mode **full-duplex** (transfert de donnÃ©es simultanÃ© dans les deux directions).

La communication repose sur une architecture **MaÃ®tre-Esclave** (un pÃ©riphÃ©rique MaÃ®tre et un ou plusieurs Esclaves). Le **MaÃ®tre** initie toujours la communication.

SPI est aussi appelÃ© protocole Ã  *quatre fils*, car il utilise quatre lignes distinctes :

- **MOSI** â€” Master Out Slave In (donnÃ©es envoyÃ©es du **MaÃ®tre** vers lâ€™**Esclave**)
- **MISO** â€” Master In Slave Out (donnÃ©es envoyÃ©es de lâ€™**Esclave** vers le **MaÃ®tre**)
- **SCLK** â€” Horloge sÃ©rie (signal dâ€™horloge gÃ©nÃ©rÃ© par le **MaÃ®tre**)
- **CS / SS** â€” Chip Select / Slave Select (utilisÃ© par le **MaÃ®tre** pour sÃ©lectionner un **Esclave** ; actif Ã  lâ€™Ã©tat BAS)

![SchÃ©ma du bus SPI]( ./images/spi1.png?500 )

---

### 2.1 Connexion de plusieurs Esclaves

Plusieurs pÃ©riphÃ©riques **Esclaves** peuvent Ãªtre connectÃ©s Ã  un seul **MaÃ®tre**. Les lignes *MOSI*, *MISO* et *SCLK* sont partagÃ©es, tandis que chaque **Esclave** possÃ¨de sa propre ligne *CS / SS*.

Quand le **MaÃ®tre** souhaite communiquer avec un **Esclave** spÃ©cifique, il place la ligne *CS / SS* correspondante Ã  lâ€™Ã©tat **BAS** (actif). Toutes les autres lignes *SS* restent **HAUTES**, et les **Esclaves** concernÃ©s ignorent la communication.

![Connexion de plusieurs Esclaves]( ./images/spi2.png?500 )

---

## 3. Transmission de DonnÃ©es en SPI

Pour dÃ©marrer la communication :
1. Le **MaÃ®tre** dÃ©finit la frÃ©quence dâ€™horloge (elle ne doit pas dÃ©passer la vitesse maximale supportÃ©e par lâ€™**Esclave**).
2. Il sÃ©lectionne lâ€™**Esclave** en plaÃ§ant sa ligne *CS / SS* Ã  **BAS**.

Pendant chaque cycle dâ€™horloge SPI (mode full-duplex) :
- Le **MaÃ®tre** envoie un bit via *MOSI*, que lâ€™**Esclave** lit.
- SimultanÃ©ment, lâ€™**Esclave** envoie un bit via *MISO*, que le **MaÃ®tre** lit.

Cela sâ€™effectue gÃ©nÃ©ralement Ã  lâ€™aide de **registres Ã  dÃ©calage** connectÃ©s en boucle dans le **MaÃ®tre** et lâ€™**Esclave**.

![Registre Ã  dÃ©calage SPI]( ./images/spi4.png?500 )

En gÃ©nÃ©ral :
- Le bit de poids fort (MSB) est envoyÃ© en premier.
- Une fois un mot transmis, les deux pÃ©riphÃ©riques ont Ã©changÃ© lâ€™ensemble du contenu de leurs registres Ã  dÃ©calage.

Une fois la transmission terminÃ©e :
- Le **MaÃ®tre** arrÃªte le signal dâ€™horloge (*SCLK*).
- Il dÃ©sÃ©lectionne lâ€™**Esclave** en plaÃ§ant la ligne *CS / SS* correspondante Ã  **HAUT**.

![Transaction SPI complÃ¨te]( ./images/spi5.png?500 )

**Remarque** : Tous les **Esclaves** non sÃ©lectionnÃ©s ignorent les lignes *SCLK* et *MOSI*, et ne pilotent pas la ligne *MISO*.  
Un seul **Esclave** peut Ãªtre sÃ©lectionnÃ© Ã  la fois par le **MaÃ®tre**.


## 4. SPI sur lâ€™ATMega324

Le microcontrÃ´leur ATMega324 fournit une interface SPI pouvant fonctionner en mode **MaÃ®tre** ou **Esclave**.

Comme dâ€™habitude, la configuration et lâ€™utilisation de cette interface impliquent lâ€™utilisation de registres de contrÃ´le, de statut et de donnÃ©es.

La description complÃ¨te des registres liÃ©s au SPI se trouve dans la [fiche technique de lâ€™ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf), chapitre : **SPI â€“ Serial Peripheral Interface** (Ã  partir de la page 214).

Voici un aperÃ§u des registres SPI les plus importants :

---

### Registre de ContrÃ´le SPI (SPCR)

| Bit   | Nom     | Description |
|-------|----------|-------------|
| 6     | **SPE**   | Activation du SPI â€” Mettre Ã  1 pour activer lâ€™interface SPI |
| 5     | **DORD**  | Ordre des bits â€” 1 : LSB en premier, 0 : MSB en premier |
| 4     | **MSTR**  | SÃ©lection MaÃ®tre/Esclave â€” 1 : mode MaÃ®tre, 0 : mode Esclave |
| 3-0   | **CPOL, CPHA, SPR1, SPR0** | PolaritÃ©, phase et frÃ©quence de lâ€™horloge SPI |

![Registre SPCR](./images/spcr.png?700)

---

### Registre de Statut SPI (SPSR)

| Bit   | Nom     | Description |
|-------|----------|-------------|
| 7     | **SPIF**  | Drapeau dâ€™interruption SPI â€” Mis Ã  1 quand un transfert est terminÃ© |

![Registre SPSR](./images/spsr.png?700)

---

### Registre de DonnÃ©es SPI (SPDR)

Le registre **SPDR** est utilisÃ© Ã  la fois pour transmettre et recevoir des donnÃ©es :
- Ã‰crire dans ce registre **dÃ©marre une nouvelle transmission** (en mode **MaÃ®tre**).
- Lire dans ce registre permet dâ€™obtenir les donnÃ©es reÃ§ues via SPI.

![Registre SPDR](./images/spdr.png?700)

---

## 5. Carte SD au format FAT

La carte de laboratoire intÃ¨gre un lecteur de carte SD qui communique avec le microcontrÃ´leur ATMega324 via le protocole SPI â€” câ€™est lâ€™application principale du TP dâ€™aujourdâ€™hui.

Le schÃ©ma ci-dessous montre comment le lecteur de carte SD est connectÃ© au microcontrÃ´leur. Remarquez que certaines broches dÃ©jÃ  utilisÃ©es dans les TP prÃ©cÃ©dents sont ici rÃ©utilisÃ©es pour les signaux SPI.

![Connexion SPI avec Carte SD](./images/spi_sd1_ss.png)

---

### Format de la carte SD : FAT32

Les cartes SD que nous utiliserons sont formatÃ©es avec le systÃ¨me de fichiers **FAT32**. Pour simplifier les opÃ©rations sur les fichiers, nous utiliserons la bibliothÃ¨que **Petit FAT Filesystem** â€” choisie pour sa faible empreinte mÃ©moire (2â€“4 Ko) et sa consommation RAM minimale (seulement 46 octets + pile).

---

### API de la bibliothÃ¨que Petit FAT Filesystem

Voici les principales fonctions fournies par la bibliothÃ¨que :

```c
FRESULT pf_mount (FATFS*);                   // Monter ou dÃ©monter un volume
FRESULT pf_open (const char*);               // Ouvrir un fichier
FRESULT pf_read (void*, WORD, WORD*);        // Lire des donnÃ©es depuis un fichier
FRESULT pf_write (const void*, WORD, WORD*); // Ã‰crire des donnÃ©es dans un fichier
FRESULT pf_lseek (DWORD);                    // DÃ©placer le pointeur de fichier
FRESULT pf_opendir (DIR*, const char*);      // Ouvrir un rÃ©pertoire
FRESULT pf_readdir (DIR*, FILINFO*);         // Lire un rÃ©pertoire
```

Ces fonctions permettent un accÃ¨s bas niveau aux fichiers depuis un systÃ¨me embarquÃ© â€” exactement ce dont nous avons besoin pour implÃ©menter un lecteur audio de base sur notre carte Ã  microcontrÃ´leur.

## 6. Exercices

ğŸ“¥ **TÃ©lÃ©chargez lâ€™archive du code de dÃ©part :**  
[lab5_skel.zip](https://ocw.cs.pub.ro/courses/_media/pm/lab/lab5_skel.zip)

Dans ce TP, vous nâ€™aurez pas beaucoup de code Ã  Ã©crire, mais il est important de bien comprendre comment votre code interagit avec le squelette fourni et le comportement des fonctions de bibliothÃ¨que que vous utiliserez.

---

### TÃ¢che 1 : ContrÃ´le SPI (2p)

ImplÃ©mentez les fonctions de communication SPI de base dans `spi.c` :
- `SPI_init()`
- `SPI_exchange()`

:::tip

- Configurez **PB4 (SS)** comme sortie et mettez-le Ã  **HAUT** pour dÃ©sactiver les interruptions SPI dÃ©clenchÃ©es par la sÃ©lection esclave.
- Suivez les exemples de la **page 217** de la fiche technique.
- RÃ©fÃ©rez-vous au schÃ©ma de cÃ¢blage de la section 5 pour identifier les broches **MOSI** et **SCLK**.
- Configurez le SPI en mode **MaÃ®tre** avec **SCLK = fosc/16** (frÃ©quence plus lente pour compatibilitÃ© avec la carte SD).
- Nâ€™oubliez pas dâ€™utiliser les registres avec suffixe `0` : `SPCR0`, `SPDR0`, etc.
- Utilisez `SPDR0` pour envoyer une donnÃ©e et recevoir la rÃ©ponse dans une seule fonction (full-duplex), remplaÃ§ant ainsi les fonctions `SPI_read()` et `SPI_write()`.

:::

---

### TÃ¢che 2 : ContrÃ´le de la carte SD (2p)

Dans `sd.c`, implÃ©mentez :
- `SD_init()`
- `SD_receive()`
- `SD_transmit()`

:::tip
- **PA2** (SS pour la carte SD) doit Ãªtre configurÃ©e en sortie. Laissez la gestion des niveaux HAUT/BAS au code squelette.
- Utilisez `SPI_exchange()` Ã  la fois pour lâ€™Ã©mission et la rÃ©ception.
- Dans `SD_receive()`, envoyez **0xFF** comme octet factice pour initier une lecture (le MaÃ®tre initie toujours la communication).
- âœ… **VÃ©rification** : AprÃ¨s avoir tÃ©lÃ©versÃ© le code, lâ€™Ã©cran LCD doit afficher `Mounted!` au lieu de `Mounting...`. Si ce nâ€™est pas le cas, appuyez sur **RESET** et effectuez un dÃ©bogage si nÃ©cessaire.
:::

---

### TÃ¢che 3 : Affichage du premier fichier (2p)

ImplÃ©mentez `init_directory()` dans `lab5.c` pour afficher le premier fichier `.wav` du dossier `/music` :
- Utilisez `pf_opendir()` pour ouvrir le dossier.
- Utilisez `pf_readdir()` pour parcourir les entrÃ©es.
- Ignorez les fichiers dont le nom commence par un underscore `_`.
- Utilisez `LCD_clear_top_line()` et `LCD_printAt()` pour afficher le nom du fichier.

---

### POINT DE CONTRÃ”LE (1pt)

> AprÃ¨s quelques secondes, lâ€™Ã©cran LCD doit afficher : **"Mounted!"**

Cela confirme que la carte SD a bien Ã©tÃ© initialisÃ©e et montÃ©e.

---

### TÃ¢che 3 â€“ Lecture de la tempÃ©rature (2pts)

Configurez lâ€™ADC et lisez la tempÃ©rature depuis un capteur analogique (par exemple LM35).

#### Ã‰tapes dâ€™implÃ©mentation :
- CrÃ©ez et implÃ©mentez `adc_init()` et `adc_read()`
- Configurez :
  - Tension de rÃ©fÃ©rence : **AVcc**
  - Prescaler ADC : **8**
- Convertissez la valeur ADC en tension, puis en Â°C (ex : `temp = voltage * 100`)
- Affichez la tempÃ©rature sur lâ€™Ã©cran **LCD**
- Envoyez aussi la lecture via **USART** (sÃ©rie)

---

### TÃ¢che 4 â€“ Enregistrement des tempÃ©ratures sur carte SD (2pts)

ImplÃ©mentez `log_temperature()` dans `lab5.c` pour sauvegarder les tempÃ©ratures dans un fichier **CSV**.

#### Exigences :
- Utilisez `SD_log_data()` pour Ã©crire dans le fichier
- Affichez la tempÃ©rature actuelle sur le **LCD**
- Envoyez la tempÃ©rature via **USART**
- Lorsquâ€™on appuie sur le bouton **PD6**, ajoutez une nouvelle ligne de log

---

### TÃ¢che 5 â€“ Navigation dans les enregistrements (2pts)

ImplÃ©mentez `init_log_display()` et `next_log_entry()` pour lire le fichier `log.csv` **ligne par ligne**.

#### FonctionnalitÃ©s :
- Affichez chaque ligne du CSV (entrÃ©e) sur le **LCD**
- En appuyant sur le bouton **PB2**, passez Ã  la **ligne suivante**
- Une fois la fin atteinte, recommencez Ã  partir du **dÃ©but**

---

### POINT DE CONTRÃ”LE (1pt)

> Vous devez pouvoir faire dÃ©filer tous les enregistrements de tempÃ©rature Ã  lâ€™aide du bouton.

Une fois terminÃ©, votre enregistreur doit permettre :
- Lecture temps rÃ©el du capteur
- Enregistrement sur bouton-poussoir
- Navigation complÃ¨te dans les logs via lâ€™Ã©cran LCD et un bouton


## ğŸ”— Liens utiles

- ğŸ“˜ [Fiche technique ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf)
- ğŸ’¾ [Tutoriel sur carte SD au format FAT](https://codeandlife.com/2012/04/25/simple-fat-and-sd-tutorial-part-3/)
- ğŸ”„ [Guide du protocole SPI](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all)

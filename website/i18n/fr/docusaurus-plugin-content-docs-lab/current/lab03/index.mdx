---
sidebar_position: 5
---
import TwoColumn from '@site/src/components/TwoColumn';
import CodeSnippet from '@site/src/components/CodeSnippet.tsx';
import * as snippets from '@site/snippets/code-snippets01.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# TP 3 : Timers, Modulation de Largeur d'Impulsion (PWM)

**Chapitres utiles du [Datasheet ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf)**

* 1. Configuration des broches ‚Äì section 1.1, page 15  
* 16. Timer/Compteur 8 bits 0 avec PWM ‚Äì section 16.9, page 140  
* 17. Timer/Compteur 16 bits 1 avec PWM ‚Äì section 17.14, page 173  
* 19. Timer/Compteur 8 bits 2 avec PWM et fonctionnement asynchrone ‚Äì section 19.11, page 202  

---

## 1. Modulation de Largeur d'Impulsion (PWM)

La **PWM** (Pulse Width Modulation) est une technique permettant de contr√¥ler la tension appliqu√©e √† un dispositif √©lectronique en le commutant rapidement entre les √©tats **ON** et **OFF**.

Ce basculement rapide g√©n√®re une **tension moyenne** d√©termin√©e par le temps pendant lequel le signal reste √† l'√©tat ON par rapport au temps total du cycle ‚Äî ce rapport s'appelle le **cycle de travail** (*duty cycle*).

![Principe PWM](./images/main-qimg-72a9c6569290abe0a85dceabaf8c7ff9.gif?direct&400)

La PWM permet un **contr√¥le num√©rique** de **signaux analogiques**, par exemple :
- Variation de l'intensit√© d'une LED
- Changement de couleur des LEDs RGB
- R√©glage de la fr√©quence d‚Äôun buzzer
- Contr√¥le de la vitesse d‚Äôun moteur

![Contr√¥le LED par PWM](./images/pwm_led.gif?direct&200)

---

### 1.1. Principe de fonctionnement

Le cycle de travail s‚Äôexprime en pourcentage du temps ON par rapport au cycle total :

$$
D[\%] = \frac{t_{on}}{t_{on} + t_{off}} \cdot 100 = \frac{pulse\_width}{period} \cdot 100
$$

La **tension moyenne** re√ßue par un dispositif est :

$$
\bar{V} = D \cdot V_{cc}
$$

![Signaux PWM avec diff√©rents cycles de travail](./images/avr_pwm_01.jpg?700)

Les signaux PWM sont g√©n√©ralement g√©n√©r√©s par des circuits num√©riques et des microcontr√¥leurs. L‚ÄôATmega324 utilise un **compteur** qui se r√©initialise p√©riodiquement et compare sa valeur avec une r√©f√©rence (`OCRn`). Lorsque le compteur d√©passe la valeur de r√©f√©rence, la sortie PWM change d‚Äô√©tat.

<details>
<summary>üõ†Ô∏è PWM par logiciel ?</summary>

La PWM peut √©galement √™tre impl√©ment√©e en logiciel avec des m√©thodes comme :
- Bit-banging
- Timers avec routines d‚Äôinterruption (ISR)

Mais pour une PWM √† **haute fr√©quence** (par exemple, dans les kHz pour les moteurs), la **PWM mat√©rielle** est bien plus efficace, car elle √©vite la surcharge du CPU caus√©e par des interruptions fr√©quentes.

</details>

---

## 2. PWM sur les Microcontr√¥leurs AVR

Dans le laboratoire pr√©c√©dent, nous avons vu que l‚ÄôATmega324 poss√®de trois timers :
- `Timer0` (8 bits)
- `Timer1` (16 bits)
- `Timer2` (8 bits)

Chaque timer peut √™tre configur√© via les registres de contr√¥le `TCCRnA` et `TCCRnB`, en utilisant les bits `WGMnx` pour s√©lectionner le mode :

- **Normal**
- **CTC (Clear Timer on Compare Match)**
- **Fast PWM** (utilis√© aujourd‚Äôhui !)
- **Phase Correct PWM**, etc.

Chaque timer dispose de deux canaux de comparaison de sortie : `OCnA` et `OCnB`. Ceux-ci sont li√©s √† des broches physiques sp√©cifiques. Consultez le chapitre **Pin Configurations** de la fiche technique pour les correspondances exactes :

![Broches de sortie PWM sur ATmega324P](./images/atmega324_pwm_pins.png?500)

Aujourd‚Äôhui, nous nous concentrons sur le **mode Fast PWM**, un mode courant adapt√© √† des applications g√©n√©rales comme la variation de luminosit√© de LED ou le contr√¥le de vitesse d‚Äôun moteur.

---

### Fast PWM

En mode **Fast PWM**, le timer compte uniquement sur le **front montant** du signal d‚Äôhorloge. Les changements de cycle de travail (duty cycle) prennent effet imm√©diatement, mais le signal n‚Äôest pas centr√© ‚Äî un d√©calage ou un artefact peut appara√Ætre lors de changements brusques du rapport cyclique.

Plusieurs variantes du mode Fast PWM sont disponibles selon les timers. Pour **Timer1**, on trouve :

- Fast PWM 8 bits : TOP = 0x00FF  
- Fast PWM 9 bits : TOP = 0x01FF  
- Fast PWM 10 bits : TOP = 0x03FF  
- Fast PWM avec TOP dans `ICR`  
- Fast PWM avec TOP dans `OCRnA`

:::note üí°

Dans ce TP, nous utiliserons uniquement le **mode Fast PWM 8 bits**. Reportez-vous √† la fiche technique pour d√©couvrir les autres modes sp√©cifiques aux timers.

:::

---

Supposons que le Timer1 soit configur√© en **Fast PWM**. Ce mode poss√®de une fr√©quence fixe et permet de modifier le cycle de travail pendant l‚Äôex√©cution.

- Avec le mode `10` pour `COM1A1:COM1A0`, le signal sur la broche `OC1A` reste √† l‚Äô√©tat HAUT pendant la mont√©e jusqu‚Äôau seuil, puis passe √† l‚Äô√©tat BAS jusqu‚Äô√† la fin du cycle.
- Pour obtenir un cycle de travail de `x%`, on d√©finit :  
  `OCR1A = x * TOP / 100`  
  o√π `TOP` vaut 255 (8 bits), 511 (9 bits), ou 1023 (10 bits), selon la configuration.

---

#### Exemple : Timer1 en Fast PWM 8 bits, mode non-invers√© avec pr√©diviseur de 1024

Fr√©quence PWM ‚âà 12 MHz / 1024 / 255 ‚âà **45 Hz**

```c
/* OC1A est PD5, doit √™tre configur√©e en sortie */
DDRB |= (1 << PD5);

/* S√©lectionner le mode Fast PWM 8 bits : WGM[3:0] = 0b0101 */
/* WGM10 et WGM11 -> TCCR1A ; WGM12 et WGM13 -> TCCR1B */
TCCR1A = (1 << WGM10);
TCCR1B = (1 << WGM12);

/* Mode non-invers√© sur OC1A : COM1A[1:0] = 0b10 */
TCCR1A |= (1 << COM1A1);

/* D√©finir le pr√©diviseur √† 1024 : CS1[2:0] = 0b101 */
TCCR1B |= (1 << CS12) | (1 << CS10);

/* D√©finir un cycle de travail √† 50% (TOP = 255, donc OCR1A = 127) */
OCR1A = 127;
```

---

### Phase Correct PWM

Bien que nous n'utilisions pas ce mode dans le TP, il est utile de comprendre comment **Phase Correct PWM** diff√®re du Fast PWM ‚Äî il offre une meilleure pr√©cision, souvent requise pour les **moteurs BLDC ou l‚Äôaudio**.

**Diff√©rence cl√©** : le compteur compte de BOTTOM jusqu‚Äô√† TOP, puis redescend jusqu‚Äô√† BOTTOM.

- La sortie est d√©finie par comparaison avec `OCRnx`, comme en Fast PWM.
- Cependant, `OCRnx` reste constant pendant tout le cycle, ce qui donne une dur√©e ON plus stable et un signal **plus propre**.
- Cela √©vite les variations de fr√©quence (jitter) ‚Äî crucial pour les moteurs, qui peuvent perdre en efficacit√© avec une PWM irr√©guli√®re.

![Chronogramme Phase Correct PWM](./images/phase_correct_pwm.png?500)

---

### Comparaison : Fast PWM vs Phase Correct PWM

![Fast PWM (gauche) vs Phase Correct PWM (droite)](./images/merged_pwm_waveforms.png?600)



## 3. Exercices

L‚Äôobjectif de ces exercices est de contr√¥ler la couleur d‚Äôune LED RGB √† l‚Äôaide de la PWM. En ajustant ind√©pendamment la luminosit√© de chaque diode (Rouge, Vert, Bleu), vous pouvez g√©n√©rer **n‚Äôimporte quelle couleur** !

Les broches de la LED RGB sont connect√©es comme suit :
- **Rouge** : broche `PD5`, fonction `OC1A` (li√©e au Timer1)
- **Vert** : broche `PD7`, fonction `OC2A` (li√©e au Timer2)
- **Bleu** : broche `PB3`, fonction `OC0A` (li√©e au Timer0)

:::info Rappel

La LED RGB est c√¢bl√©e avec une **anode commune** / configuration "active-bas" ‚Äî la LED s‚Äôallume lorsque la broche est √† l‚Äô√©tat BAS (LOW), et s‚Äô√©teint lorsqu‚Äôelle est √† l‚Äô√©tat HAUT (HIGH).

:::

---

### T√¢che 0

1. T√©l√©chargez et ex√©cutez le [projet de d√©part (ZIP)](https://ocw.cs.pub.ro/courses/_media/pm/lab/lab3-2023-2024/lab3-skel-2023-2024.zip).
   - Que remarquez-vous sur la carte ?
   - Consultez le moniteur s√©rie ‚Äî vous souvenez-vous comment la temporisation √©tait g√©r√©e dans le TP pr√©c√©dent ?
   - Comment se comporte la LED ? Quel timer est utilis√© et dans quel mode ?
   - O√π l‚Äôintensit√© est-elle mise √† jour ? Quelle est l‚Äôentr√©e de la formule, et o√π est appliqu√©e la sortie ?

---

### T√¢che 1

1. Faisons en sorte que la LED **bleue** se comporte de la m√™me mani√®re.
   - Utilisez le Timer0 (`OC0A` sur `PB3`) en **mode Fast PWM**.
   - Consultez la **Section 12.9** du [Datasheet ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf) pour une bonne utilisation des registres ‚Äî les registres du Timer0 sont diff√©rents de ceux du Timer1 !
   - Faites pulser la LED bleue **plus rapidement** que la rouge, et en **parall√®le**.
   - Que remarquez-vous ?

---

### T√¢che 2

1. C‚Äôest au tour de la LED **verte** !
   - Probl√®me : `PD7` (OC2A) est utilis√© par le Timer2, d√©j√† utilis√© pour les ticks syst√®me de `millis()`...
   - Solution : nous allons g√©n√©rer la PWM manuellement en utilisant les **interruptions** :
     - Le Timer2 compte de 0 √† 188 et d√©clenche une interruption via `COMPA` (pour incr√©menter `systicks`).
     - Le deuxi√®me comparateur `COMPB` du Timer2 d√©clenche une interruption √† une valeur entre 0‚Äì188.
     - Dans l‚ÄôISR de `COMPA` : allumer la LED verte ‚Üí mettre le GPIO √† LOW.
     - Dans l‚ÄôISR de `COMPB` : √©teindre la LED verte ‚Üí mettre le GPIO √† HIGH.
     - Le cycle de travail est d√©fini par `OCR2B`.

:::warning
Gardez `OCR2A = 188` pour conserver le bon fonctionnement de `millis()`.
:::

---

### T√¢che 3

1. Parcourez toutes les couleurs √† l‚Äôaide de l‚Äôespace colorim√©trique **HSV** :
   - Convertissez HSV ‚Üí RGB en utilisant la fonction `convert_HSV_to_RGB()` fournie.
   - Faites varier la **Teinte (Hue)** dans le temps, gardez **Saturation = 1**, **Valeur = 1** (luminosit√© maximale).
   - Utilisez les ticks syst√®me pour animer la couleur de mani√®re fluide, comme pour la pulsation des LEDs.
   - Assurez-vous de d√©sactiver tout code en conflit qui modifierait l‚Äôintensit√© des LEDs.

![Roue des Couleurs HSV](./images/hue-wheel.png?direct&400)

---

### T√¢che 4 (Bonus)

1. Utilisez le **haut-parleur** connect√© √† `PD4` (√©galement `OC1B`) pour **jouer une m√©lodie** depuis le module `sound.c`.
   - `surprise_notes[]` contient les fr√©quences.
   - `durations[]` contient les dur√©es des notes.
   - Dans `update_notes()`, reconfigurez le Timer1 √† chaque nouvelle note :
     - Utilisez le **mode CTC** (`OCR1A` d√©finit la valeur TOP ‚Üí contr√¥le la fr√©quence).
     - R√©glez `OCR1B = OCR1A / 2` pour un cycle de travail de 50% (onde carr√©e).
     - Appelez `update_notes()` toutes les **25 ms** via `systicks`.
     - Remettez `TCNT1 = 0` apr√®s chaque modification de `OCR1A` pour √©viter les d√©calages temporels.

---

### Bonus 2

Combinez :
- L‚Äôanimation RGB (cycle HSV) **et** (and)
- La lecture de la m√©lodie (via le haut-parleur)

‚Äî les deux fonctionnant **simultan√©ment** et de mani√®re fluide.

---

## 4. Liens Utiles

- [1] [Tutoriel Vid√©o sur la PWM](http://www.afrotechmods.com/groovy/PWM_tutorial/PWM_tutorial.htm)
- [2] [Guide PWM sur AVR Freaks](http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=68302)
- [3] [Secrets de la PWM sur Arduino](https://docs.arduino.cc/tutorials/generic/secrets-of-arduino-pwm)
- [4] [Datasheet ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf)

---
sidebar_position: 8
---
import TwoColumn from '@site/src/components/TwoColumn';
import CodeSnippet from '@site/src/components/CodeSnippet.tsx';
import * as snippets from '@site/snippets/code-snippets01.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# TP 6 : I2C (Inter-Integrated Circuit)

Ce TP est consacrÃ© Ã  la comprÃ©hension et Ã  lâ€™utilisation du protocole I2C sur le microcontrÃ´leur ATmega324P. Pour aller plus loin, vous pouvez consulter la [fiche technique de lâ€™ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf) et lâ€™article [Wikipedia : I2C](https://fr.wikipedia.org/wiki/I%C2%B2C).

---

## 1. Quâ€™est-ce que lâ€™I2C ?

I2C (aussi appelÃ© IIC ou TWI â€“ Two-Wire Interface) est un protocole de communication synchrone, sÃ©rie, semi-duplex, dÃ©veloppÃ© par Philips en 1982.  
Il est couramment utilisÃ© pour la communication entre microcontrÃ´leurs et capteurs ou mÃ©moires.

Un bus I2C utilise deux lignes :
- **SDA** â€“ Ligne de donnÃ©es sÃ©rie
- **SCL** â€“ Ligne dâ€™horloge sÃ©rie

Lâ€™horloge est toujours gÃ©nÃ©rÃ©e par le maÃ®tre. Un seul pÃ©riphÃ©rique peut transmettre Ã  la fois sur la ligne SDA, ce qui fait de lâ€™I2C un protocole semi-duplex.

![]( ./images/i2c-slaves.jpeg?450)

---

## 2. Fonctionnement de lâ€™I2C

Contrairement au SPI, lâ€™I2C ne nÃ©cessite pas de ligne *Slave Select* sÃ©parÃ©e.  
Chaque esclave possÃ¨de une **adresse unique** (gÃ©nÃ©ralement sur 7 bits), et la communication est toujours initiÃ©e par le **MaÃ®tre**.

Une communication I2C se divise en :
- Une **trame dâ€™adresse**
- Une ou plusieurs **trames de donnÃ©es**

Les messages sont encadrÃ©s par des signaux spÃ©ciaux :
- **Condition de dÃ©marrage (Start)**
- **Condition dâ€™arrÃªt (Stop)**

![](./images/introduction-to-i2c-message-frame-and-bit-2.png?600)

---

### 2.1 Condition de dÃ©marrage

Avant dâ€™envoyer lâ€™adresse de lâ€™esclave, le **MaÃ®tre** doit gÃ©nÃ©rer une **condition de dÃ©marrage** :
- Pendant que SCL est Ã  lâ€™Ã©tat HAUT, SDA passe de lâ€™Ã©tat HAUT Ã  BAS.

Cela indique Ã  tous les esclaves dâ€™Ã©couter lâ€™adresse Ã  venir.

---

### 2.2 Trame dâ€™adresse

AprÃ¨s la condition de dÃ©marrage, le maÃ®tre envoie :
- 7 bits : adresse de lâ€™esclave (A6â€“A0)
- 1 bit : R/W (0 = Ã©criture, 1 = lecture)

Lâ€™esclave qui reconnaÃ®t son adresse envoie un **ACK** en forÃ§ant SDA Ã  lâ€™Ã©tat BAS pendant le 9e cycle dâ€™horloge.

Si SDA reste Ã  lâ€™Ã©tat HAUT pendant ce 9e cycle, câ€™est un **NACK**.

---

### 2.3 Trames de donnÃ©es

Si un ACK est reÃ§u, le maÃ®tre continue avec :
- **Ã‰criture** : le maÃ®tre envoie des octets, lâ€™esclave acquitte chaque octet.
- **Lecture** : lâ€™esclave envoie des octets, le maÃ®tre acquitte chaque octet.

Pour terminer une lecture, le **MaÃ®tre envoie un NACK** au lieu dâ€™un ACK aprÃ¨s le dernier octet.

Chaque octet est suivi dâ€™un ACK/NACK selon la direction de transfert.

---

### 2.4 Condition dâ€™arrÃªt

Pour terminer la communication, le maÃ®tre gÃ©nÃ¨re une **condition dâ€™arrÃªt** :
- SDA passe de lâ€™Ã©tat BAS Ã  HAUT **aprÃ¨s** que SCL est HAUT.

![](./images/image6.png?700)

---
:::info

 Plusieurs esclaves peuvent partager le mÃªme bus, mais chacun possÃ¨de une adresse unique (gÃ©nÃ©ralement sur 7 bits).  
 Le bit de poids faible de la trame dâ€™adresse indique sâ€™il sâ€™agit dâ€™une lecture (1) ou dâ€™une Ã©criture (0).  
 Une fois lâ€™esclave sÃ©lectionnÃ©, la transmission de donnÃ©es peut commencer.

:::

## 3. Registres de configuration I2C

Le microcontrÃ´leur ATmega324P supporte les modes **MaÃ®tre** et **Esclave** pour lâ€™I2C.

---

### Registre de dÃ©bit TWI (`TWBR`)

![](./images/twbr.png?600)

- Ce registre dÃ©finit le diviseur de frÃ©quence qui dÃ©termine la vitesse de lâ€™horloge SCL en mode **MaÃ®tre**.

---

### Registre de contrÃ´le TWI (`TWCR`)

![](./images/twcr.png?600)

- Ce registre permet dâ€™activer la communication I2C, de gÃ©nÃ©rer les conditions Start/Stop, de gÃ©rer les acquittements et de dÃ©tecter les collisions.

| Bit | Nom   | Description |
|-----|--------|-------------|
| 7   | TWINT | Drapeau dâ€™interruption TWI (mis Ã  1 par le matÃ©riel, effacÃ© en Ã©crivant 1) |
| 6   | TWEA  | Activation de lâ€™acquittement : 1 = envoie ACK, 0 = envoie NACK |
| 2   | TWEN  | Activation du module TWI : 1 = actif, 0 = inactif |

---

### Registre de statut TWI (`TWSR`)

![](./images/twsr.png?600)

- Indique lâ€™Ã©tat actuel du TWI (start envoyÃ©, adresse reconnue, etc.) et les rÃ©glages du prÃ©scaler.

---

### Registre de donnÃ©es TWI (`TWDR`)

![](./images/twdr.png?600)

- Contient lâ€™octet Ã  transmettre (TX) ou lâ€™octet reÃ§u prÃ©cÃ©demment (RX), selon le contexte.

---

## 4. Utilisation du module I2C sur AVR

La configuration du module I2C est relativement simple â€” il suffit principalement de dÃ©finir la frÃ©quence de lâ€™horloge.

### Exemple : Initialiser lâ€™I2C Ã  100kHz

```c
void twi_init(void)
{
  // RÃ©gler le prÃ©scaler Ã  1 (TWPS = 00)
  TWSR = (0 << TWPS0);

  // RÃ©gler le registre de dÃ©bit
  // Formule : TWBR = (F_CPU / SCL_freq - 16) / (2 * prescaler)
  TWBR = 52; // Pour une horloge CPU de 12MHz et un SCL Ã  100kHz
}
```

Cependant, effectuer une transaction I2C complÃ¨te est plus complexe et nÃ©cessite les Ã©tapes suivantes :

1. Configurer `TWCR` pour Ã©mettre une **condition START**.
2. Attendre la fin de lâ€™opÃ©ration (vÃ©rifier `TWCR.TWINT`).
3. Charger lâ€™**adresse de lâ€™esclave** dans `TWDR` et lancer la transmission.
4. Attendre et vÃ©rifier lâ€™**ACK** via `TWSR`.
5. Transmettre ou recevoir les octets de donnÃ©es via `TWDR`, en attendant Ã  chaque Ã©tape.
6. Ã‰mettre une **condition STOP** Ã  lâ€™aide dâ€™un autre drapeau dans `TWCR`.

---

## 5. Capteur de pression â€“ MPL3115A2

La carte de TP inclut un capteur de pression et de tempÃ©rature **MPL3115A2** qui communique via I2C.

### Brochage I2C pour le capteur :

| Signal I2C | Broche GPIO |
|------------|-------------|
| Enable     | PA6         |
| SCL        | PC0         |
| SDA        | PC1         |

La communication avec le capteur nÃ©cessite un **accÃ¨s en lecture/Ã©criture Ã  ses registres internes** via I2C. Avant toute opÃ©ration, lâ€™**adresse du registre** doit Ãªtre envoyÃ©e.

La table des registres et leurs adresses respectives se trouve dans la [fiche technique du MPL3115A2](https://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf), section 14.

![: Table des registres MPL3115A2]( ./images/mpl3115a2-registers.jpeg?400 )


## 6. Exercices

TÃ©lÃ©chargez lâ€™[archive du squelette de code](https://ocw.cs.pub.ro/courses/_media/pm/lab/lab6/lab6-skel-2023-2024.zip) et suivez les instructions marquÃ©es avec `TODO`.

---

### **TÃ¢che 0** â€“ Initialisation de base de lâ€™I2C

ComplÃ©tez les fonctions `twi_init`, `twi_start` et `twi_stop` dans le fichier `twi.c`.

> ğŸ’¡ Les dÃ©finitions de constantes utiles se trouvent dans [avr-libc util/twi.h](https://www.nongnu.org/avr-libc/user-manual/group__util__twi.html)

---

### **TÃ¢che 1** â€“ Lecture et Ã©criture

ImplÃ©mentez les fonctions `twi_read_ack`, `twi_read_nack` et `twi_write` dans `twi.c`.

> ğŸ’¡ Astuce : consultez le tableau `23-2`, page 268 de la [fiche technique ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf) pour un exemple complet.

---

### **TÃ¢che 2** â€“ DÃ©couverte des pÃ©riphÃ©riques sur le bus I2C

ImplÃ©mentez `twi_discover` dans `twi.c`. Cette fonction doit envoyer une adresse en lecture (SLA_R) Ã  toutes les adresses possibles du bus I2C (0â€“127) et dÃ©tecter celles qui rÃ©pondent avec un ACK.

- Affichez les adresses des pÃ©riphÃ©riques dÃ©tectÃ©s via le port sÃ©rie.
- Veillez Ã  appeler cette fonction dans `main()`.

> ğŸ’¡ Astuce : utilisez le registre `TWSR` pour vÃ©rifier si un ACK a Ã©tÃ© reÃ§u. Consultez le tableau `23-4`, page 275 de la fiche technique pour les codes de statut.

**Pour envoyer une adresse de lecture ou dâ€™Ã©criture :**

```c
// Adresse de lecture
(ADRESSE_PERIPHERIQUE << 1) | 1

// Adresse dâ€™Ã©criture
ADRESSE_PERIPHERIQUE << 1
```

ğŸ“Œ Lâ€™adresse du capteur est `0x60` â†’ lecture = `0xC1`, Ã©criture = `0xC0`.

---

### **TÃ¢che 3** â€“ Capteur de pression MPL3115A2

Nous allons maintenant configurer et lire les valeurs du capteur **MPL3115A2** via I2C.

#### TÃ¢che 3.1 â€“ Initialiser le capteur

ComplÃ©tez `mpl3115a2_init` dans `mpl3115a2.c`. Cette fonction doit Ãªtre appelÃ©e une seule fois dans `main()` avant la boucle principale.

ğŸ“Œ RÃ©glez `CTRL_REG1` pour fonctionner en **mode pression** (assurez-vous que le bit `ALT` est Ã  0).

---

#### TÃ¢che 3.2 â€“ Lire la pression et la tempÃ©rature

ComplÃ©tez `mpl3115a2_read_pressure` et `mpl3115a2_read_temperature` dans `mpl3115a2.c`. Appelez-les dans la boucle principale et affichez les valeurs en sÃ©rie.

:::tip Astuce 1
 La section `14` de la [fiche technique MPL3115A2](https://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf) dÃ©crit les registres.
:::

:::tip Astuce 2
Formule de la pression (format Q18.2) :

```c
PRESSURE = (OUT_P_MSB << 12) | (OUT_P_CSB << 4) | (OUT_P_LSB >> 4);
```
:::

---

### SÃ©quence de lecture dâ€™un registre

Utilisez la sÃ©quence suivante pour lire un registre :

```c
twi_start();
twi_write(ADRESSE_PERIPHERIQUE << 1);        // SLA + W
twi_write(ADRESSE_REGISTRE);                 // registre Ã  lire
twi_start();                                 // START rÃ©pÃ©tÃ©
twi_write((ADRESSE_PERIPHERIQUE << 1) | 1);  // SLA + R

uint8_t data = 0;
twi_read_nack(&data);
twi_stop();
```

---

âœ… Une fois les tÃ¢ches terminÃ©es, vous devriez pouvoir communiquer avec le MPL3115A2, dÃ©tecter son adresse, le configurer et lire des valeurs valides de pression et de tempÃ©rature.

---

### ğŸ”— Liens utiles

- [Fiche technique ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf)
- [Fiche technique MPL3115A2](https://www.nxp.com/docs/en/data-sheet/MPL3115A2.pdf)
- [Tutoriel I2C par SparkFun](https://learn.sparkfun.com/tutorials/i2c/all)

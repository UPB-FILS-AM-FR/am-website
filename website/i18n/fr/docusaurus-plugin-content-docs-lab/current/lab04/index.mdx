---
sidebar_position: 6
---
import TwoColumn from '@site/src/components/TwoColumn';
import CodeSnippet from '@site/src/components/CodeSnippet.tsx';
import * as snippets from '@site/snippets/code-snippets01.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# TP 4 : Convertisseur Analogique-Num√©rique (ADC)

Ce TP a pour but de vous familiariser avec le convertisseur analogique-num√©rique int√©gr√© au microcontr√¥leur ATmega324P.

## 1. Mesure des Signaux Analogiques

Pour mesurer des signaux analogiques dans un syst√®me num√©rique, ils doivent d‚Äôabord √™tre convertis en valeurs num√©riques discr√®tes. Un convertisseur analogique-num√©rique (**ADC**) est un circuit √©lectronique qui transforme une tension analogique en une valeur num√©rique.

![Signal Analogique](./images/semnalanalogic.png?600)

Une caract√©ristique essentielle d‚Äôun ADC est sa **r√©solution**, qui indique le nombre de valeurs de sortie discr√®tes qu‚Äôil peut produire sur l‚Äôintervalle de mesure. Comme les r√©sultats de la conversion sont stock√©s sous forme binaire, la r√©solution est g√©n√©ralement exprim√©e en **bits**.  
Le **quantum de mesure** ‚Äî le plus petit changement d√©tectable par l‚ÄôADC ‚Äî se calcule comme suit : plage de tension d‚Äôentr√©e divis√©e par le nombre de valeurs de sortie possibles (2^N).

![R√©solution ADC](./images/rezolutie.png?800)

Par exemple, un ADC 10 bits fournit 2^10 = 1024 valeurs diff√©rentes. Pour une plage de mesure de 0V √† 5V, le quantum serait (5V - 0V)/1024 ‚âà 4,8 mV.

Une autre caract√©ristique importante est la **fr√©quence d‚Äô√©chantillonnage**, qui d√©finit √† quelle fr√©quence les valeurs sont converties, et influence la fid√©lit√© de la reconstitution du signal d‚Äôorigine apr√®s traitement num√©rique. Ci-dessous, une illustration montre comment un signal reconstruit par un DAC peut diff√©rer de l‚Äôoriginal selon la fr√©quence d‚Äô√©chantillonnage.

![Th√©or√®me de Nyquist](./images/illustration-of-the-nyquist-shannon-sampling-theorem-if-sampling-at-a-frequency-that-is.png?800)

### Th√©or√®me de Nyquist

Pour reproduire un signal sans perte, la fr√©quence d‚Äô√©chantillonnage doit √™tre **au moins deux fois** sup√©rieure √† la fr√©quence maximale pr√©sente dans le signal. Cela s‚Äôapplique aussi bien aux sinuso√Ødes qu‚Äôaux signaux complexes comme la voix ou la musique.

- L‚Äôaudition humaine couvre de 20Hz √† 20kHz, mais la voix humaine se situe g√©n√©ralement entre 20‚Äì4000Hz.
- Les syst√®mes t√©l√©phoniques √©chantillonnent souvent √† 8000Hz pour assurer une reproduction intelligible.
- Les CD audio utilisent 44100Hz pour couvrir toute la gamme audible avec une haute fid√©lit√©.

### Types d‚ÄôADC

Selon leur fonctionnement interne, les ADC peuvent √™tre class√©s en plusieurs types :

- ADC Flash (Conversion directe)
- ADC √† Approximation Successive (SAR)
- ADC Int√©grateur (pente simple, double pente)
- ADC Sigma-Delta (1 bit ou sur√©chantillonnage)

---

<details>
<summary>Cliquez pour afficher plus de d√©tails</summary>

### R√©solution

La r√©solution d√©finit le nombre de valeurs discr√®tes que l‚ÄôADC peut fournir. Par exemple :
- R√©solution 8 bits = 256 niveaux (valeurs de 0 √† 255)
- Pour une plage de 0‚Äì5V avec une r√©solution de 8 bits : chaque niveau ‚âà 5V / 256 ‚âà 0,0195V

### Fr√©quence d‚Äô√âchantillonnage

La fr√©quence d‚Äô√©chantillonnage est la fr√©quence √† laquelle le signal analogique est captur√© :
- Doit √™tre ‚â• 2√ó la fr√©quence du signal d‚Äôentr√©e (fr√©quence de Nyquist)
- Un sous-√©chantillonnage provoque un **repliement spectral** (*aliasing*), o√π les hautes fr√©quences sont mal interpr√©t√©es comme des fr√©quences plus basses

![Probl√®me d'Aliasing](./images/adc_2.png?600)

### Architectures ADC

#### ADC Flash

- Le plus rapide, utilise une banque de comparateurs en parall√®le
- Conversion presque instantan√©e mais n√©cessite beaucoup de composants mat√©riels

![ADC Flash](./images/adc_3.png?300)

#### ADC √† Approximation Successive (SAR)

- Utilise une recherche binaire pour converger vers la tension d‚Äôentr√©e
- Plus compact et √©conomique que le Flash, mais plus lent

![ADC SAR](./images/adc_4.png?500)

#### ADC Sigma-Delta

- Offre une haute r√©solution et peu de bruit
- Id√©al pour des applications o√π la vitesse est moins critique
- Utilise un circuit d‚Äô√©chantillonnage et de maintien (*sample-and-hold*) pour conserver la tension analogique pendant la conversion

![ADC Sigma-Delta](./images/adc_5.png?500)

</details>



## 2. Le Convertisseur ADC de l‚ÄôATmega324P

Le convertisseur analogique-num√©rique int√©gr√© dans le microcontr√¥leur ATmega324P est un **ADC √† approximation successive**. Il offre une **r√©solution allant jusqu‚Äô√† 10 bits** et peut mesurer toute tension comprise entre 0 et 5V via huit entr√©es analogiques multiplex√©es (broches du port A). Il peut √©galement amplifier les signaux de faible amplitude avec des gains s√©lectionnables de 0 dB (1x), 20 dB (10x) ou 46 dB (200x).

Ce convertisseur est contr√¥l√© √† l‚Äôaide de deux registres de statut et de contr√¥le (`ADCSRA` et `ADCSRB`) et d‚Äôun registre de s√©lection de multiplexeur (`ADMUX`). Les deux premiers contr√¥lent le d√©clenchement de la conversion, l‚Äôactivation des interruptions, etc. Le registre du multiplexeur s√©lectionne le canal d‚Äôentr√©e ainsi que la source de tension de r√©f√©rence.  
√âtant donn√© que les registres du processeur sont sur 8 bits et que l‚ÄôADC fournit un r√©sultat jusqu‚Äô√† 10 bits, le r√©sultat est r√©parti en un **octet de poids faible** et un **octet de poids fort**.

> **Formule de conversion :**  
>
> `ADC = V_in * 1024 / V_ref`  
> `V_in = ADC * V_ref / 1024`

O√π `V_in` est la tension mesur√©e, et `V_ref` la tension de r√©f√©rence s√©lectionn√©e.

---

### Tension de R√©f√©rence

Selon la plage de signal √† mesurer, il est possible de s√©lectionner une **tension de r√©f√©rence** diff√©rente pour am√©liorer la pr√©cision des lectures. L‚ÄôATmega324P permet l‚Äôutilisation de :
- AVCC (tension d‚Äôalimentation)
- R√©f√©rences internes de 1.1V ou 2.56V
- R√©f√©rence externe via la broche AREF

---

### Pr√©diviseur (Prescaler)

L‚ÄôADC n√©cessite un signal d‚Äôhorloge pour d√©terminer la dur√©e d‚Äôune conversion. Comme l‚Äôhorloge du microcontr√¥leur est trop rapide, un **pr√©diviseur** est utilis√© pour la ralentir.

> **F_ADC = F_CPU / PRESCALER**

Les valeurs de pr√©diviseur vont de 2 √† 128. Un pr√©diviseur plus √©lev√© signifie une horloge ADC plus lente, donc des conversions plus pr√©cises. Plus de d√©tails dans la section 25.4 de la [fiche technique ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf).

---

### Modes de Fonctionnement

- **Mode Conversion Unique** : effectue une seule conversion. D√©bute en positionnant `ADSC = 1`. Il se r√©initialise automatiquement √† la fin.
- **Mode Continu (Free Running)** : encha√Æne les conversions en continu. `ADSC` reste √† 1 et les r√©sultats sont mis √† jour en permanence.
- **D√©clenchement par Interruption Externe** : d√©marre une conversion sur front montant d‚Äôune broche.
- **Mode Comparateur Analogique** : compare deux signaux analogiques. (Non utilis√© dans ce TP.)
- **Mode Timer** : utilise des √©v√©nements de timer (ex. d√©bordement ou comparaison) pour d√©clencher les conversions.

![ADC avec Timer](./images/adctimer.png)

---

### Registres

#### `ADMUX` ‚Äì Registre de S√©lection du Multiplexeur ADC

![ADMUX](./images/adc_6.png?500)

- **Bits 7:6 ‚Äì REFS1:0** ‚Üí S√©lection de la tension de r√©f√©rence  
  ![Bits REFS](./images/adc_7.png?500)
- **Bit 5 ‚Äì ADLAR** ‚Üí Alignement gauche/droite du r√©sultat
- **Bits 4:0 ‚Äì MUX4:0** ‚Üí S√©lection du canal d‚Äôentr√©e analogique  
  ![Bits MUX](./images/adc_8.png?500)

---

#### `ADCSRA` ‚Äì Registre de Contr√¥le et de Statut ADC A

![ADCSRA](./images/adcsra.png?600)

- **Bit 7 ‚Äì ADEN** : Active l‚ÄôADC  
- **Bit 6 ‚Äì ADSC** : D√©marre la conversion  
- **Bit 5 ‚Äì ADATE** : Active le d√©clenchement automatique  
- **Bit 4 ‚Äì ADIF** : Indicateur de fin de conversion  
- **Bit 3 ‚Äì ADIE** : Active l‚Äôinterruption ADC  
- **Bits 2:0 ‚Äì ADPS2:0** : D√©finissent le pr√©diviseur  
  ![Bits ADPS](./images/adc_10.png?500)

---

#### `ADCSRB` ‚Äì Registre de Contr√¥le et de Statut ADC B

![ADCSRB](./images/adcsrb.png?600)

- **Bits 2:0 ‚Äì ADTS2:0** : Source du d√©clenchement automatique  
  ![Bits ADTS](./images/adc_13.png?500)

---

### Exemple

**Initialisation pour lire depuis la broche PA1 (ADC1) :**
```c
ADMUX = 0;
// S√©lection du canal ADC1
ADMUX |= (1 << MUX0);
// Utilisation de AVCC comme tension de r√©f√©rence
ADMUX |= (1 << REFS0);

ADCSRA = 0;
// Pr√©diviseur r√©gl√© √† 128
ADCSRA |= (7 << ADPS0);
// Activation de l‚ÄôADC
ADCSRA |= (1 << ADEN);
```

**Lecture du r√©sultat de conversion :**
```c
// D√©marrer la conversion
ADCSRA |= (1 << ADSC);
// Attendre la fin de la conversion
while (ADCSRA & (1 << ADSC));

uint16_t result = ADC; // R√©sultat combin√© sur 10 bits
```


## 4. Exercices

L‚Äôobjectif de ces exercices est d‚Äôutiliser le **convertisseur analogique-num√©rique (ADC)** int√©gr√© au microcontr√¥leur ATmega324P pour effectuer diverses lectures (boutons multiplex√©s via des diviseurs de tension, capteur de temp√©rature).

T√©l√©chargez le squelette de code : ![lab_4_skel.zip](https://ocw.cs.pub.ro/courses/_media/pm/lab/lab_4_skel.zip)

---

### **T√¢che 0**

Compl√©tez le squelette de code fourni (`adc.c`) en impl√©mentant une fonction similaire √† `analogRead(uint8_t pin)`. Cette fonction doit :

- Effectuer une **conversion unique** sur la broche analogique sp√©cifi√©e.
- **Bloquer** l‚Äôex√©cution jusqu‚Äô√† ce que le r√©sultat soit disponible.
- Retourner la **valeur num√©rique convertie**.

---

### **T√¢che 1**

√Ä l‚Äôaide de la fonction `analogRead()`, lisez les valeurs du **capteur de temp√©rature** connect√© √† la broche **PA0**.

- Touchez le capteur (avec pr√©caution) avec votre doigt et observez comment les lectures changent.
- Optionnel : affichez la valeur via la sortie s√©rie.

---

### **T√¢che 2**

Les boutons 1 √† 6 sont **multiplex√©s** sur une seule broche analogique **PA5**, √† l‚Äôaide de **diviseurs de tension**. Consultez le sch√©ma mat√©riel pour une explication visuelle.

√âtapes :
1. D√©terminez les **plages de valeurs analogiques** retourn√©es lorsque chaque bouton est press√©.
2. D√©finissez des valeurs seuils appropri√©es √† l‚Äôaide de macros `#define`.
3. Impl√©mentez la logique suivante :
   - **BTN2** ‚Üí allumer la **LED rouge**
   - **BTN3** ‚Üí allumer la **LED verte**
   - **BTN5** ‚Üí allumer la **LED bleue**

---

### **T√¢che 3**

Configurez l‚ÄôADC pour qu‚Äôil d√©marre **automatiquement** une conversion sur le **capteur de temp√©rature (PA0)** **toutes les secondes**, en utilisant le **Timer1**.

Conseils :
- Le Timer1 est d√©j√† configur√© pour d√©clencher des interruptions toutes les secondes.
- Consultez la fiche technique pour :
  - Le bit **ADATE (Auto Trigger Enable)**
  - Le champ **ADTS (Auto Trigger Source)** dans les registres `ADCSRA` et `ADCSRB`
- Optionnellement, au lieu d‚Äôutiliser le d√©clenchement automatique, vous pouvez **appeler manuellement** `analogRead()` dans le gestionnaire d‚Äôinterruption du Timer1.

---

## 5. Liens Utiles

- üìò [Fiche technique ATmega324P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42743-ATmega324P_Datasheet.pdf)
- üîß [Documentation mat√©rielle PM-Board](https://github.com/dantudose/PM-Board)
- üî≤ [Boutons multiplex√©s sur une seule broche](https://www.instructables.com/Accessing-5-buttons-through-1-Arduino-pin-Revisi)

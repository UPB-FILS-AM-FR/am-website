---
sidebar_position: 4
---

import TwoColumn from '@site/src/components/TwoColumn';
import CodeSnippet from '@site/src/components/CodeSnippet.tsx';
import * as snippets from '@site/snippets/code-snippets01.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


# Laboratoire 2 : Interruptions, Timers

### **Chapitres utiles du** [Datasheet ATmega324](https://ocw.cs.pub.ro/courses/_media/pm/doc8272.pdf)
* **1. Configuration des broches**
  * Section 1.1 - Page 2
* **7. C≈ìur du processeur AVR**
  * Section 7.3 - Page 11
  * Section 7.7 - Page 16
* **12. Interruptions**
  * Tableau 12-1 - Page 61
* **13. Interruptions externes**
  * Section 13.1 - Page 67
  * Sections 13.2.4-13.2.9 - Page 69
* **16. Minuteries/Compteurs 16 bits (Timer/Counter1 et Timer/Counter3) avec PWM**
  * Sections 16.1-16.3 - Page 111
  * Section 16.5 - Page 117
  * Section 16.7 - Page 120
  * Sections 16.9.1-16.9.2 - Page 123
  * Section 16.11 - Page 132

:::warning 
Les chapitres r√©f√©renc√©s proviennent du [Datasheet ATmega324](https://ocw.cs.pub.ro/courses/_media/pm/doc8272.pdf), un document disponible sur **le bureau des ordinateurs du laboratoire**.  
L'ordre des chapitres peut varier dans d'autres versions de la fiche technique !
:::

---

## **Objectif**

Ce laboratoire vise √† vous familiariser avec les **interruptions mat√©rielles** et les **timers** sur le microcontr√¥leur ATmega324.  
Dans cette s√©ance, nous utiliserons les timers **uniquement pour le comptage**, sans g√©n√©rer de signaux PWM.  
La fonctionnalit√© PWM sera explor√©e dans le **prochain laboratoire**.

---

## **1. Interruptions**

Une **interruption mat√©rielle** est un signal synchrone ou asynchrone provenant d'un p√©riph√©rique, indiquant qu'un √©v√©nement doit √™tre trait√© par le processeur.  
Lorsqu'une interruption est d√©clench√©e, elle **suspend l'ex√©cution normale** du programme et d√©clenche l'ex√©cution d'une **Routine de Service d'Interruption (ISR).**

### **Pourquoi utiliser des interruptions ?**
Les interruptions √©liminent le besoin de **boucles d‚Äôinterrogation (polling)** o√π le processeur v√©rifie constamment un √©v√©nement sur un p√©riph√©rique.  
Gr√¢ce aux interruptions :
- Les p√©riph√©riques peuvent notifier le processeur **uniquement en cas de besoin**.
- Le processeur est **libre** d‚Äôex√©cuter d‚Äôautres t√¢ches **jusqu‚Äô√† ce qu‚Äôun √©v√©nement se produise**.
- Le programme s'ex√©cute de mani√®re **plus efficace**.

### **Gestion des interruptions**
Avant d'ex√©cuter une **ISR**, le processeur **sauvegarde son √©tat actuel** :
- **Compteur de programme (PC)**
- **Registres d‚Äô√©tat**
- **Variables affect√©es par l‚Äôex√©cution de l‚ÄôISR**

Ces informations sont stock√©es en **m√©moire**, g√©n√©ralement sur une **pile (stack)**.  
Une fois l‚ÄôISR termin√©e, l‚Äô√©tat **pr√©c√©dent** est restaur√© et le **programme principal reprend** son ex√©cution √† l'endroit o√π il a √©t√© interrompu.

---

## **Table de Vecteurs d'Interruption (IVT)**

Pour associer une interruption √† une **fonction ISR sp√©cifique**, le processeur utilise une **Table de Vecteurs d'Interruption (IVT)**, repr√©sent√©e dans le sch√©ma ci-dessous.

Chaque interruption est assign√©e √† une **adresse m√©moire fixe** o√π se trouve la **fonction ISR** correspondante.  
Lorsqu'une interruption se produit, le processeur saute √† l‚Äô**adresse ISR** correspondante dans l'IVT.

**Priorit√© des interruptions :**  
- **Adresses les plus basses ‚Üí Priorit√© la plus √©lev√©e**
- Les interruptions situ√©es **au d√©but de l'IVT** sont trait√©es **en premier**.

---

## **Table de Vecteurs d'Interruption pour l'ATmega324**

| N¬∞ Vecteur | Adresse Programme | Source | D√©finition de l'Interruption |
|------------|------------------|--------|------------------------------|
| 1  | 0000  | RESET         | R√©initialisation externe, mise sous tension, Reset Brown-out, Reset Watchdog, et Reset JTAG AWR |
| 2  | 0002  | INT0          | Demande d'interruption externe 0 |
| 3  | 0004  | INT1          | Demande d'interruption externe 1 |
| 4  | 0006  | INT2          | Demande d'interruption externe 2 |
| 5  | 0008  | PCINT0        | Demande d'interruption par changement d‚Äô√©tat 0 |
| 6  | 000A  | PCINT1        | Demande d'interruption par changement d‚Äô√©tat 1 |
| 7  | 000C  | PCINT2        | Demande d'interruption par changement d‚Äô√©tat 2 |
| 8  | 000E  | PCINT3        | Demande d'interruption par changement d‚Äô√©tat 3 |
| 9  | 0010  | WDT           | Interruption de temporisation Watchdog |
| 10 | 0012  | TIMER2_COMPA  | Comparaison A du Timer/Counter2 |
| 11 | 0014  | TIMER2_COMPB  | Comparaison B du Timer/Counter2 |
| 12 | 0016  | TIMER2_OVF    | D√©passement du Timer/Counter2 |
| 13 | 0018  | TIMER1_CAPT   | Capture d‚Äô√©v√©nement du Timer/Counter1 |
| 14 | 001A  | TIMER1_COMPA  | Comparaison A du Timer/Counter1 |
| 15 | 001C  | TIMER1_COMPB  | Comparaison B du Timer/Counter1 |
| 16 | 001E  | TIMER1_OVF    | D√©passement du Timer/Counter1 |
| 17 | 0020  | TIMER0_COMPA  | Comparaison A du Timer/Counter0 |
| 18 | 0022  | TIMER0_COMPB  | Comparaison B du Timer/Counter0 |
| 19 | 0024  | TIMER0_OVF    | D√©passement du Timer/Counter0 |
| 20 | 0026  | SPI_STC       | Transfert s√©rie SPI termin√© |
| 21 | 0028  | USART0_RX     | R√©ception USART0 termin√©e |
| 22 | 002A  | USART0_UDRE   | Registre de donn√©es USART0 vide |
| 23 | 002C  | USART0_TX     | Transmission USART0 termin√©e |
| 24 | 002E  | ANALOG_COMP   | Comparateur analogique |
| 25 | 0030  | ADC           | Conversion ADC termin√©e |
| 26 | 0032  | EE_READY      | EEPROM pr√™te |
| 27 | 0034  | TWI           | Interface s√©rie √† deux fils (I2C) |
| 28 | 0036  | SPM_READY     | M√©moire programme pr√™te |
| 29 | 0038  | USART1_RX     | R√©ception USART1 termin√©e |
| 30 | 003A  | USART1_UDRE   | Registre de donn√©es USART1 vide |
| 31 | 003C  | USART1_TX     | Transmission USART1 termin√©e |
| 32 | 003E  | TIMER3_CAPT   | Capture d‚Äô√©v√©nement du Timer/Counter3 |
| 33 | 0040  | TIMER3_COMPA  | Comparaison A du Timer/Counter3 |
| 34 | 0042  | TIMER3_COMPB  | Comparaison B du Timer/Counter3 |
| 35 | 0044  | TIMER3_OVF    | D√©passement du Timer/Counter3 |

---

D'apr√®s le tableau ci-dessus, en plus des **interruptions des composants internes** (timers, interfaces s√©rie, convertisseurs analogique-num√©rique), il existe √©galement des **interruptions des p√©riph√©riques externes** :  
‚úÖ **INT0-INT2**  
‚úÖ **PCINT0-PCINT3**  

La **diff√©rence** entre ces deux types d'interruptions externes r√©side dans leurs capacit√©s et leur niveau de granularit√©.

### **Interruptions INTn**
- Les signaux des interruptions **INTn** proviennent de :
  - **Port D** (broches 2, 3)
  - **Port B** (broche 2)
- Elles peuvent d√©clencher une interruption :
  - Sur un **front montant** ou un **front descendant**
  - Ou sur un **niveau bas (0)**, selon la configuration.

### **Interruptions PCINTn**
- Les interruptions **PCINTn** se d√©clenchent sur **les deux fronts** (d'o√π le nom **Pin Change INTerrupt**).
- **8 broches sont multiplex√©es** sur une **seule interruption**.
- Bien que les **signaux PCINT** puissent √™tre activ√©s individuellement, la broche exacte ayant d√©clench√© l'interruption doit √™tre d√©termin√©e en v√©rifiant le **registre PINn**.
- **Les changements simultan√©s de plusieurs broches ne peuvent pas √™tre distingu√©s.**

:::warning 
Pour les **interruptions par changement d‚Äô√©tat**, ne confondez pas le **vecteur d'interruption (ex. : PCINT0)** avec l'**interruption r√©elle (ex. : PCINT0 (PA0))**.  
Le mapping entre les vecteurs et les interruptions se trouve dans la **Section 30, Page 555** du [datasheet](https://ocw.cs.pub.ro/courses/_media/pm/doc8272.pdf).
:::

## **Broches d'Interruption Externe sur l'ATmega324**

![Broches d'Interruption Externe sur l'ATmega324](./images/irq_pins.png?500)

:::tip
Lorsqu'une interruption se produit, en plus de sauvegarder l'√©tat, le processeur **d√©sactive** les interruptions.  
√Ä la fin de la routine d'interruption, elles sont **r√©activ√©es**.  
Les interruptions peuvent √©galement √™tre r√©activ√©es **manuellement √† l'int√©rieur du gestionnaire** (ex. : si nous sommes dans un gestionnaire recevant une trame via une interface s√©rie et souhaitons activer une interruption de timer).
:::

---

## **1.1. Utilisation des Interruptions**

Pour activer une interruption, suivez ces √©tapes :

### **1Ô∏è‚É£ Activer le m√©canisme d'interruption globale**
La gestion des interruptions doit √™tre activ√©e explicitement (bit **I - Global Interrupt Enable** dans le registre `SREG`).  
Pour activer et d√©sactiver ce bit, utilisez les fonctions suivantes :

```c
// Activer les interruptions
sei();  

// D√©sactiver les interruptions
cli();
```

---

### **2Ô∏è‚É£ Configurer le p√©riph√©rique qui g√©n√©rera les interruptions**
Par exemple, `INT0`, `INT1` et `INT2` sont configur√©s via le **registre EICRA**  
(External Interrupt Control Register A, section **13.2.1, page 67** du [datasheet](https://ocw.cs.pub.ro/courses/_media/pm/doc8272.pdf)).

Pour les **interruptions par changement d‚Äô√©tat (PCINTn)**, utilisez le **registre PCICR**.

### **Registre EICRA**
![Registre EICRA](./images/eicra.png?700)

### **Modes de D√©clenchement des Interruptions**
![Modes EICRA](./images/eicra2.png?700)

#### **Exemples de Configuration**
```c
// Interruption externe : Configurer INT0 pour se d√©clencher sur tout changement logique
EICRA |= (1 << ISC00);    

// Interruption par changement d'√©tat : Activer l‚Äôinterruption sur changement d'√©tat, configurer PCIE1 pour analyser PCMSK1
PCICR |= (1 << PCIE1); 
```

:::tip
Une **interruption externe** peut √™tre configur√©e pour se d√©clencher sur :
- **Un front montant**
- **Un front descendant**
- **Tout changement d‚Äô√©tat**  

üìå Voir **Table 13-1** dans le [datasheet](https://ocw.cs.pub.ro/courses/_media/pm/doc8272.pdf) pour plus de d√©tails.  

üìå Les **interruptions par changement d‚Äô√©tat** se d√©clenchent sur **n'importe quel changement de niveau**, il faut donc **v√©rifier explicitement la valeur du signal dans le gestionnaire d‚Äôinterruption**.
:::

---

### **3Ô∏è‚É£ Impl√©menter la Routine de Service d'Interruption (ISR)**

Les gestionnaires d'interruptions doivent √™tre mapp√©s √† des **adresses m√©moire fixes** dans la **table de vecteurs d‚Äôinterruption**.  
Utilisez la macro `ISR()` pour les d√©finir, en passant le **type d'interruption** appropri√©.

#### **Exemple : Gestion des interruptions INT0 et PCINT1**
```c
ISR(INT0_vect) {
  // Code pour l'interruption externe
}

ISR(PCINT1_vect) {
  // Code pour l'interruption par changement d‚Äô√©tat

  if ((PINB & (1 << PB1)) == 0) { 
     // Interruption d√©clench√©e par la broche PB1
  }
}
```

## **Activation des Interruptions et Test du Programme**

Pour activer les interruptions externes, configurez le **registre de masque des interruptions externes (EIMSK)** :
- Les bits **INT2:0** contr√¥lent l'activation des interruptions externes (**INT0-INT2**).

Pour les **interruptions par changement d‚Äô√©tat**, configurez le **registre correspondant** (par ex., `PCMSK1` pour les interruptions sur des broches sp√©cifiques).

```c
// Activer l'interruption externe INT0
EIMSK |= (1 << INT0);     

// Activer l'interruption par changement d‚Äô√©tat PCINT9 (PB1)
PCMSK1 |= (1 << PCINT9); 

// Activer les interruptions globales
sei();
```

---

<details>
<summary>
üìå **Registres suppl√©mentaires pour la gestion des interruptions**
</summary>

Pour une **description compl√®te** de ces registres, consultez le [datasheet](https://ocw.cs.pub.ro/courses/_media/pm/doc8272.pdf)  
(*Interruptions*, *Interruptions Externes*).

### **Registre d'√âtat (SREG)**
- Stocke les **indicateurs d'√©tat** d√©finis par l'ALU.
- Contient le bit **I**, qui active/d√©sactive les interruptions globales.
- **N'est pas sauvegard√©** lorsqu'une interruption se produit.
- D√©crit dans le chapitre *C≈ìur du processeur AVR*.

üìå **Registre SREG**
![Registre SREG](./images/sreg.png)

---

### **Registre de Contr√¥le MCU (MCUCR)**
- Bit `IVSEL` : D√©finit **l'emplacement de la table des vecteurs d'interruption**  
  (`0` = D√©but de la m√©moire Flash, `1` = Section Boot Loader).
- Bit `IVCE` : Permet d'√©crire dans le bit `IVSEL`.

üìå **Registre MCUCR**
![Registre MCUCR](./images/mcucr.png?700)

---

### **Registre de Masque des Interruptions Externes (EIMSK)**
- Les bits **INT2:0** contr√¥lent l'activation des interruptions externes.
- Si `INT2:0` **ET** le bit `I` dans `SREG` sont √† `1`,  
  les interruptions externes sont **activ√©es** sur la broche correspondante.

</details>

---

## **1.2 Utilisation des Interruptions dans avr-gcc**

La biblioth√®que **avr-libc** fournit l'interface `<avr/interrupt.h>`  
pour d√©finir des **routines de service d'interruption (ISR)**.

Chaque microcontr√¥leur poss√®de une **table de vecteurs sp√©cifique**,  
d√©clar√©e dans le fichier **IO header correspondant**  
(pour **ATMega324**, voir `iom324.h`).

### **Vecteurs d'Interruption Courants**
| Interruption | Vecteur | Description |
|  --- | --- | --- |
| TIMER1_COMPA | TIMER1_COMPA_vect | Comparaison sur Timer 1, Seuil A |
| TIMER1_COMPB | TIMER1_COMPB_vect | Comparaison sur Timer 1, Seuil B |
| TIMER1_OVF | TIMER1_OVF_vect | D√©passement du Timer 1 |
| PCINT1 | PCINT1_vect | Interruption par changement d'√©tat sur Port B |
| ... | ... | ... |

---

### **D√©finition d'une ISR**
Utilisez la macro `ISR()` pour cr√©er un gestionnaire d'interruption :

```c
#include <avr/interrupt.h>

ISR(INT0_vect) {
    // Code de gestion de l'interruption
}
```

---

### **R√®gles de Gestion des Interruptions**
‚úÖ **Pas de valeur de retour** : Le processeur reprend l'ex√©cution **l√† o√π il s'√©tait arr√™t√©**  
‚úÖ **Minimiser le temps d'ex√©cution** : L'ISR **bloque** l'ex√©cution du programme principal  
‚úÖ **Manipuler les variables partag√©es avec pr√©caution** :
- **Utiliser `volatile`** pour les variables partag√©es, afin d'√©viter l'optimisation du compilateur.
- **Faire attention aux conditions de concurrence** lors de la modification de **variables multi-octets (16/32 bits)**.

---

<details>
<summary>
üìå **Les interruptions peuvent √™tre d√©clar√©es avec des options sp√©cifiques**
</summary>

```c
#include <avr/interrupt.h>

ISR(vector, flag) {
    // Code de gestion de l'interruption
}
```

La macro `ISR()` :
- D√©finit le gestionnaire pour un **p√©riph√©rique sp√©cifique**.
- **Sauvegarde le registre `SREG`** avant l'ex√©cution.
- Appelle l'instruction **`reti`** √† la fin.

### **Options ISR**
| Option | Description |
| --- | --- |
| **ISR_BLOCK** | **Comportement par d√©faut** : Les interruptions globales sont d√©sactiv√©es dans l'ISR. |
| **ISR_NOBLOCK** | Permet les **interruptions imbriqu√©es** (utile pour la gestion de priorit√©s). |
| **ISR_NAKED** | **Supprime le prologue/√©pilogue** (pas de sauvegarde `SREG`, pas d'appel `reti`). |
| **ISR_ALIASOF** | Rend une ISR **alias** d'une autre ISR. |

#### **Exemple : Alias d'Interruptions**
```c
#include <avr/interrupt.h>

ISR(INT0_vect) {
    // Gestionnaire d'interruption pour INT0
}

ISR(INT1_vect, ISR_ALIASOF(INT0_vect)) {
    // INT1 utilise le m√™me gestionnaire que INT0
}
```
</details>

---

### **Fonctions Utilitaires Suppl√©mentaires**
| Fonction | Description |
| --- | --- |
| **`sei()`** | **Active** les interruptions globales (`I` bit dans `SREG` = 1). |
| **`cli()`** | **D√©sactive** les interruptions globales (`I` bit dans `SREG` = 0). |
| **`reti()`** | **Retourne depuis une ISR**, r√©activant les interruptions. |

---

:::warning
**‚ö† Une interruption active sans ISR provoquera un Reset syst√®me !**  
Si une interruption activ√©e **n'a pas de gestionnaire**, le syst√®me sera **r√©initialis√©**.
:::


## **2. Minuterie (Timer)**

### **2.1. Fonctionnement d'un Timer**

Un **Timer/Compteur** mesure des intervalles de temps fixes et peut d√©clencher des **interruptions** lorsque l'intervalle mesur√© expire.  
Une fois initialis√©, un timer fonctionne **ind√©pendamment** du CPU, √©liminant ainsi le besoin de boucles d‚Äôattente.

### **Composants de Base d‚Äôun Timer sur l‚ÄôATmega324**
1. **Registre Compteur (`TCNT`)** - Mesure les intervalles de temps et s‚Äôincr√©mente √† une fr√©quence d√©finie.
2. **Pr√©diviseur (Prescaler)** - Divise la fr√©quence d‚Äôhorloge en fonction des besoins de l‚Äôapplication.
3. **Registre de Comparaison (`OCRn`)** - Stocke une valeur seuil. Si `TCNT` atteint cette valeur, une **interruption est g√©n√©r√©e**.

üìå **Sch√©ma Fonctionnel du Timer (ATmega324)**  
![Sch√©ma Fonctionnel du Timer](./images/timer_block.png?600)

L‚ÄôATmega324 dispose de **trois timers** :
- **Deux timers 8 bits** (Timer0 & Timer2)
- **Un timer 16 bits** (Timer1)

Les timers peuvent aussi fonctionner en **mode PWM** pour g√©n√©rer des **signaux de commande de tension variable**, qui seront √©tudi√©s lors du prochain laboratoire.

---

### **2.2. Modes de Fonctionnement du Timer**

Les timers peuvent fonctionner en diff√©rents **modes**, chacun d√©finissant :
- La plage de comptage.
- Le comportement du comptage (**incr√©mentation uniquement** ou **incr√©mentation/d√©cr√©mentation**).
- Quand le compteur se r√©initialise.

üìå **Modes utilis√©s dans ce laboratoire :**
| Mode | Description | Comportement du Compteur | Propri√©t√©s |
|  --- | --- | --- | --- |
| **Normal** | *D√©marre √† 0*        *Compte jusqu‚Äô√† `0xFFFF`* | ![Mode Normal](./images/timer_normal_v2.png?350) | *Fr√©quence fixe bas√©e sur l‚Äôhorloge & le pr√©diviseur* |
| **CTC (Clear Timer on Compare)** | *D√©marre √† 0*        *Compte jusqu‚Äô√† `OCRnA`*        *Se r√©initialise √† la valeur seuil* | ![Mode CTC](./images/timer_ctc_v2.png?350) | *Fr√©quence variable bas√©e sur l‚Äôhorloge, le pr√©diviseur & la valeur de comparaison* |

**Termes Cl√©s :**
- **BOTTOM** : Valeur minimale de comptage (`0`).
- **TOP** : Valeur maximale de comptage.
- **MAX** : Valeur la plus haute possible (255 pour les timers 8 bits, 65535 pour les timers 16 bits).  
  - **TOP = MAX** en **Mode Normal**.

---

### **2.3. Registres du Timer**

| Timer | Registres | Description |
|  --- | --- | --- |
| **Timer0 (8 bits)** | `TCNT0` | Registre du compteur (valeur courante du compteur) |
|  | `TCCR0A`, `TCCR0B` | Registres de contr√¥le (configuration du timer) |
|  | `OCR0A`, `OCR0B` | Registres de comparaison (d√©finition des seuils d‚Äôinterruption) |
|  | `TIMSK0`, `TIFR0` | Registres pour activer/d√©sactiver les interruptions & indicateurs d‚Äô√©tat |
| **Timer1 (16 bits)** | `TCNT1H/L` | Registre compteur 16 bits |
|  | `TCCR1A`, `TCCR1B`, `TCCR1C` | Registres de contr√¥le |
|  | `OCR1AH/L`, `OCR1BH/L` | Registres de comparaison 16 bits |
|  | `TIMSK1`, `TIFR1` | Registres d‚Äôinterruption & indicateurs d‚Äô√©tat |
|  | `ICR1H/L` | Registre de Capture d‚ÄôEntr√©e - stocke la valeur du compteur sur un √©v√©nement externe |
| **Timer2 (8 bits)** | *M√™me registres que Timer0* | Timer2 prend en charge une **horloge externe** via `TOSC1` & `TOSC2` |
|  | `ASSR`, `GTCCR` | Registres pour le fonctionnement asynchrone |

:::tip  
**Les interruptions doivent √™tre activ√©es globalement (bit `I` dans `SREG` doit √™tre activ√©).**  
Utilisez `sei();` pour activer les interruptions globales.
:::

---

## **2.4. Configuration du Timer**

### **D√©finition du Mode du Timer**
Pour configurer un mode de timer :
1. D√©finissez les bits **`WGM`** dans le registre **TCCRnA** correspondant.
2. D√©finissez le **seuil de comparaison**.

**Exemple : Configurer Timer0 en mode CTC, comptant jusqu'√† 5**
```c
TCCR0A |= (1 << WGM01); // Mode CTC activ√©
OCR0A = 5;              // D√©finition du seuil de comparaison
```

---

### **Configuration du Pr√©diviseur**
Les valeurs du pr√©diviseur sont d√©finies √† l‚Äôaide des **bits CSx** dans `TCCRnB`.

**Exemple : D√©finir le pr√©diviseur du Timer2 √† 256**
```c
TCCR2B |= (1 << CS22) | (1 << CS21); // Pr√©diviseur de 256
```

---

### **Activation des Interruptions du Timer**
Pour d√©clencher une **interruption lors d‚Äôune comparaison**, activez le bit correspondant dans `TIMSKx`.

**Exemple : Activer l‚Äôinterruption de Comparaison A pour Timer1**
```c
#include <avr/interrupt.h>

ISR(TIMER1_COMPA_vect) {
  // Gestionnaire d'interruption pour la comparaison A du Timer1
}

void init_timer1() {
  TIMSK1 |= (1 << OCIE1A); // Activer l‚Äôinterruption Comparaison A du Timer1
}

int main() {
  sei();         // Activer les interruptions globales
  init_timer1(); // Initialiser Timer1
  while (1) {
    // Boucle principale
  }
}
```

---

## **2.5. Gestion des Registres 16 bits**
Certains registres (`TCNT1`, `OCR1A/B`, `ICR1`) sont **16 bits** mais accessibles **8 bits √† la fois**.  
- √âcrire le **byte de poids fort en premier** garantit des mises √† jour atomiques.

**Exemple : √âcriture dans `OCR1A` (registre 16 bits)**
```c
OCR1AH = (seuil >> 8); // √âcrire le byte de poids fort d‚Äôabord
OCR1AL = seuil;        // Puis √©crire le byte de poids faible
```

:::tip  
Cela est **automatiquement g√©r√© par le compilateur** en C lorsque les registres **sans suffixe `H` ou `L`** sont utilis√©s.
:::

---

## **2.6. Calculateur de Timer**
Pour configurer un timer :
- Choisissez un **pr√©diviseur**.
- D√©finissez une **limite de comptage**.
- Calculez les valeurs en fonction de la **fr√©quence d√©sir√©e** et de l‚Äô**horloge syst√®me**.

**Formule pour la fr√©quence d‚Äôinterruption (`f_int`)** :
```
f_int = f_clk / (pr√©diviseur * (tc + 1))
```
**Calcul de la valeur du Timer (`tc`)** :
```
tc = f_clk / (pr√©diviseur * f_int) - 1
```

üìå **Exemple : G√©n√©rer une interruption √† 1Hz (Horloge = 12MHz)**  
| Pr√©diviseur | Limite de Compteur (`tc`) | Timer1 (16 bits) | Timer0,2 (8 bits) | Remarques |
|  --- | --- | --- | --- | --- |
| **1** | 11,999,999 | ‚ùå Impossible (D√©passement 16 bits) | ‚ùå Impossible (D√©passement 8 bits) | D√©passement |
| **8** | 1,499,999 | ‚ùå Impossible | ‚ùå Impossible | D√©passement |
| **64** | 187,499 | ‚ùå Impossible | ‚ùå Impossible | D√©passement |
| **256** | 46,874 | ‚úÖ Valide (Utiliser Timer1) | ‚ùå Impossible | **Requiert Timer1** |
| **1024** | 11,717 | ‚ùå Impossible | ‚ùå Impossible | **Valeur non exacte** |

:::tip  
**Timer2 prend en charge des pr√©diviseurs de 32 et 128 (Voir ATmega324 Datasheet, Section 17.11.2, Page 160).**
:::

---

## **Outils de Calcul en Ligne**
Si vous avez besoin de **valeurs pr√©cises des registres**, utilisez ces outils :

- **Calculateur de Timer/Compteur ATmega**  
  [ATmega Timer Calculator](https://web.archive.org/web/20180312235028/https://et06.dunweber.com/atmega_timers/)

  <iframe src="https://web.archive.org/web/20180312235028/https://et06.dunweber.com/atmega_timers/" width="100%" height="500px"></iframe>


- **Calculateur d‚ÄôInterruptions de Timer pour Arduino**  
  [AVR Timer Calculator](https://www.arduinoslovakia.eu/application/timer-calculator)


<Tabs>
<TabItem value="lab_work" label="Travail en labo">


### **T√¢che 1.1 : Impl√©mentation de `millis()`**
- Impl√©mentez une fonction similaire √† `millis()` d'Arduino, qui retourne le temps √©coul√© depuis le d√©marrage ou le dernier reset du microcontr√¥leur (¬µC).
- Configurez **USART0** avec les m√™mes param√®tres que dans le laboratoire pr√©c√©dent.
- Envoyez un message choisi au PC **toutes les 1 seconde**.

üìå **Astuces :**
- La **fr√©quence d'horloge du ¬µC est de 12MHz**.  
- Utilisez les **formules de la section pr√©c√©dente** pour calculer le **pr√©diviseur** et la **valeur du registre de comparaison** pour le timer.
- **Timer2** offre plus d‚Äôoptions de pr√©diviseurs, ce qui en fait un bon choix.

---

### **T√¢che 1.2 : Anti-rebond des boutons**
- Une **m√©thode de filtrage (debounce)** est n√©cessaire pour d√©tecter correctement les **appuis courts sur un bouton**.
- Comment peut-on utiliser **`millis()`** pour √©liminer les fausses lectures ?
- **√âcrivez une fonction en pseudocode** illustrant votre solution.

---

### **T√¢che 2 : R√©impl√©mentation de l'Exercice 3 du Laboratoire 0 en utilisant les Timers et Interruptions**
- **Utilisez des timers et interruptions** pour d√©tecter les appuis sur les boutons et **contr√¥ler le clignotement des LEDs**.

üìå **Rappel (Lab 0, Exercice 3) :**
- **BTN1 :** Change la couleur de la **LED RGB** (**Rouge ‚Üí Vert ‚Üí Bleu ‚Üí Rouge**).
- **BTN2 :** Active/D√©sactive le **clignotement de la LED**.

---

### **T√¢che 3 : Contr√¥le d‚Äôun Buzzer avec des Boutons**
- Utilisez les **boutons `PD6` et `PB2`** pour contr√¥ler un buzzer.
- **Un bouton s√©lectionne la fr√©quence** parmi trois valeurs (ex. **100Hz, 200Hz, 300Hz**).
- **Le deuxi√®me bouton doit √™tre maintenu enfonc√©** pour que le buzzer √©mette un son.
- **Utilisez la LED RGB** pour indiquer la fr√©quence s√©lectionn√©e.

---

### **T√¢che 4 (BONUS) : Correction d‚ÄôErreur du Timer**
- La fonction **`millis()`** accumule une **erreur** au fil du temps en raison des impr√©cisions de division de la fr√©quence d‚Äôhorloge.
- **Calcul :**  
  - Apr√®s combien de cycles du timer **l'erreur d√©passe-t-elle 1ms** ?
- **Proposez une m√©thode** pour r√©duire cette erreur.
- **Impl√©mentez la m√©thode de correction propos√©e**.

---


</TabItem>


<TabItem value="homework" label="Devoirs">

:::info

**Utilisez ce** [**squelette de devoirs Tinkercad**](https://www.tinkercad.com/things/kcBoaJMamLq-l02timerinterrupts?sharecode=0OTaTcQsxhidmfeSklLvesX5KHotedJvZVVPS4pSP_s) ‚ÜóÔ∏è 

:::

### **T√¢che 1.1 : Impl√©mentation de `millis()`**
- Impl√©mentez une fonction similaire √† `millis()` d'Arduino, qui retourne le temps √©coul√© depuis le d√©marrage ou le dernier reset du microcontr√¥leur (¬µC).
- Configurez **USART0** avec les m√™mes param√®tres que dans le laboratoire pr√©c√©dent.
- Envoyez un message choisi au PC **toutes les 1 seconde**.

üìå **Astuces :**
- La **fr√©quence d'horloge du ¬µC est de 12MHz**.  
- Utilisez les **formules de la section pr√©c√©dente** pour calculer le **pr√©diviseur** et la **valeur du registre de comparaison** pour le timer.
- **Timer2** offre plus d‚Äôoptions de pr√©diviseurs, ce qui en fait un bon choix.

---

### **T√¢che 1.2 : Anti-rebond des boutons**
- Une **m√©thode de filtrage (debounce)** est n√©cessaire pour d√©tecter correctement les **appuis courts sur un bouton**.
- Comment peut-on utiliser **`millis()`** pour √©liminer les fausses lectures ?
- **√âcrivez une fonction en pseudocode** illustrant votre solution.

---

### **T√¢che 2 : R√©impl√©mentation de l'Exercice 3 du Laboratoire 0 en utilisant les Timers et Interruptions**
- **Utilisez des timers et interruptions** pour d√©tecter les appuis sur les boutons et **contr√¥ler le clignotement des LEDs**.

üìå **Rappel (Lab 0, Exercice 3) :**
- **BTN1 :** Change la couleur de la **LED RGB** (**Rouge ‚Üí Vert ‚Üí Bleu ‚Üí Rouge**).
- **BTN2 :** Active/D√©sactive le **clignotement de la LED**.

---

### **T√¢che 3 : Contr√¥le d‚Äôun Buzzer avec des Boutons**
- Utilisez les **boutons `PD6` et `PB2`** pour contr√¥ler un buzzer.
- **Un bouton s√©lectionne la fr√©quence** parmi trois valeurs (ex. **100Hz, 200Hz, 300Hz**).
- **Le deuxi√®me bouton doit √™tre maintenu enfonc√©** pour que le buzzer √©mette un son.
- **Utilisez la LED RGB** pour indiquer la fr√©quence s√©lectionn√©e.

---

### **T√¢che 4 (BONUS) : Correction d‚ÄôErreur du Timer**
- La fonction **`millis()`** accumule une **erreur** au fil du temps en raison des impr√©cisions de division de la fr√©quence d‚Äôhorloge.
- **Calcul :**  
  - Apr√®s combien de cycles du timer **l'erreur d√©passe-t-elle 1ms** ?
- **Proposez une m√©thode** pour r√©duire cette erreur.
- **Impl√©mentez la m√©thode de correction propos√©e**.

---

</TabItem>
</Tabs>